/*
 * Test a small Fermat number for primality. If known factors are given then test the cofactor for 
 * probable primality.
 *
 * Values: F is the Fermat number (2^2^n + 1), P is the product of known factors, C is the remaining
 * cofactor.
 *
 * Prints Res64 (hexadecimal) and Selfridge-Hurwitz residues (decimal, optionally octal) on each 
 * step to compare with other programs.
 *
 * The steps are:
 *   Pepin Fermat test:
 *      R = 3^((F-1)/2) mod F               If (and only if) R == -1 mod F, then F is prime
 *   Suyama cofactor test:
 *      A = R^2 mod F = 3^(F-1) mod F       Prime95/mprime type 5 residue
 *      B = 2^(P-1) mod F
 *      (A - B) mod C                       Cofactor C is prime iff (A - B) mod C == 0
 *      GCD (A-B, C)                        Cofactor C is not a prime power if GCD (A-B, C) = 1
 *
 * cofact can be run in one of three modes:
 *   mode 1 (default):  Test a Fermat number for primality using the Pepin test.
 *                      Then, if known factors are provided, use the Pepin residue to perform the 
 *                      Suyama PRP test on the cofactor.
 *   mode 2 (-cpr):     Perform all steps in mode 1. Also, compare the Suyama A residue calculated 
 *          (or -c)     by cofact to the A residue read from the proof file generated by mprime 
 *                      when testing the same cofactor.
 *   mode 3 (-upr):     Read the Suyama A residue for a Fermat number from the mprime proof file 
 *          (or -u)     (assumes it is correct), then perform the Suyama PRP test on the cofactor.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>

#include <errno.h>
#include <gmp.h>

#include "gwnum.h"

#define CMD_LEN 1024        // Length of the command line string
#define NAME_LEN 64         // Length of the proof filename
#define TIME_STRING_LEN 64
#define N_FACT 10           // Number of Fermat factors supported

#define tv_secs(tv) (tv.tv_sec + tv.tv_usec / 1000000.0)
#define tv_msecs(tv) (tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0)

const char *prog_name  = "cofact";
const char *prog_vers  = "0.7c";
const char *build_date = __DATE__;
const char *build_time = __TIME__;

mpz_t mask64;       // 64 bit mask for print_residues
mpz_t r64;          // 64 LSBs of a residue

// Print the label followed by Res64 (hex), Res 2^36 (decimal), Res 2^36-1 (decimal), Res 2^35-1 (decimal)
void print_residues (mpz_t n, int octal, char *name) {
    unsigned long res64, res36, res36m1, res35m1;

    mpz_and (r64, n, mask64);
    res64 = mpz_get_ui (r64);
    res36   = mpz_tdiv_ui (n, 0x1000000000L);
    res36m1 = mpz_tdiv_ui (n,  0xFFFFFFFFFL);
    res35m1 = mpz_tdiv_ui (n,  0x7FFFFFFFFL);
    printf ("%s Residue mod 2^64 2^36 2^36-1 2^35-1: 0x%016lX %ld %ld %ld\n", name, res64, res36, res36m1, res35m1);
    if (octal) {
        printf ("%s Residue mod 2^64 2^36 2^36-1 2^35-1: 0x%016lX %lo %lo %lo (octal)\n", name, res64, res36, res36m1, res35m1);
    }
}

// Print an mpz_t number with a label. Used for debug only.
void print_mpz (mpz_t n, int base, char *name) {

    printf ("%s = ", name);
    mpz_out_str (stdout, base, n);
    printf ("\n");
}

void usage (int verbose) {
    printf ("Usage: cofact [-cpr file] [-cdhikmouv [file]] [-p iter] [-sep] [-t threads] [-upr file] [-kf] Fermat_exponent factor_1 factor_2 ...\n");
    printf ("    -cpr file    Read the Suyama A residue from the mprime proof file and compare it to the A residue calculated by cofact (mode 2)\n");
    printf ("    -c file      Same as -cpr, but -c can be combined with other flags\n");
    printf ("    -d           Print debug information\n");
    printf ("    -h           Print this help and exit\n");
    printf ("    -i           Special flag for printing interim Pepin residues at certain values for F8, F17, and F22\n");
    printf ("    -k           Same as -kf below, but -k can be combined with other flags\n");
    printf ("    -m           Special flag for reducing Suyama A and B values modulo C\n");
    printf ("    -o           Additionally print Selfridge-Hurwitz residues in octal (default is decimal only)\n");
    printf ("    -u file      Same as -upr, but -u can be combined with other flags\n");
    printf ("    -v           Print more verbose information (also, you may use -hv to get more verbose help)\n");
    printf ("    -p iter      Print progress every iter iterations, instead of the default of every 10%% of total iterations for longer runs)\n");
    printf ("    -sep         Print a separator at the end of the run to better see multiple runs' output in a single output file\n");
    printf ("    -t threads   Specifies the number of threads to use in the gwnum library. Defaults to 1.\n");
    printf ("    -upr file    Read the Suyama A residue from the mprime proof file and use it to complete the Suyama test (mode 3)\n\n");
    printf ("    -kf          Use currently known prime factors (as of 2020) for the Fermat number being tested, if available.\n");
    printf ("                 Only Fermat numbers F12 to F19, F21 to F23, and F25 to F30 have known factors stored.\n");
    printf ("                 Do NOT use -kf if you believe you have a new factor that you wish to test in addition to known factors.\n");
    printf ("\n");
    if (verbose) {
        printf ("----------------------------------------------------------------------------------------------------\n");
        printf ("\n");
        printf ("This version of cofact is principally by Gary B. Gostin, with various custom modifications by \n");
        printf ("Catherine X. Cowie for outputting data for her investigation of historical compositeness tests,\n");
        printf ("published at: \n");
        printf ("    https://64ordle.au/fermat/historical/\n");
        printf ("\n");
        printf ("These modifications include:\n");
        printf ("\n");
        printf ("Flag -i to output interim residues for particular Fermat numbers:\n");
        printf ("    F8, 246th iteration (cf. Morehead & Western, 1909),\n");
        printf ("    F17, 20th iteration (cf. Selfridge & Hurwitz, 1964);\n");
        printf ("    F22, 13 interim values from 126,000 to 4,182,000 (cf. Trevisan & Carvalho, 1995);\n");
        printf ("\n");
        printf ("Flag -m for reducing the Suyama A and B values by mod C, prior to evaluating \n");
        printf ("(A - B) mod C (cf. Crandall, Doenias, et al., 1995);\n");
        printf ("\n");
        printf ("Option -o for printing octal representations of Selfridge-Hurwitz residues;\n");
        printf ("\n");
        printf ("Super-verbose flag -sv for outputting full residues of Pepin tests and from \n");
        printf ("saved proofs, full values of cofactors, outputting the binary representations \n");
        printf ("of cofactors (yikes), and other what-not.\n");
        printf ("\n");
        printf ("Use with care! The super-verbose flag -sv also includes the normal -v level of \n");
        printf ("verbosity, and switches on -d (debug), -i, -m, and -o flags as well. It is not a \n");
        printf ("good idea to run -sv on Fermat numbers greater than F10 unless you need or want\n");
        printf ("full listings of cofact's doings.\n");
        printf ("\n");
        printf ("Any of the following flags can be run together, i.e. as -cdhikmouv:\n");
        printf ("    -c or -u,   to either check or use a proof file;\n");
        printf ("    -i, -m, -o, for various modifications to the Pepin or Suyama tests;\n");
        printf ("    -d, -v,     for debug or verbose modes;\n");
        printf ("    -h or -hv,  for help or verbose help;\n");
        printf ("    -k,         to use the known factors for a Fermat number.\n");
        printf ("\n");
        printf ("Conversely, the -cpr, -p, -sep, -sv, -t, and -upr flags must be entered separately.\n");
        printf ("\n");
        printf ("The following factors are known as of 2020, and programmed with the -k or -kf flag:\n");
        printf ("    F12: 6 known factors\n");
        printf ("    F13: 4 known factors\n");
        printf ("    F15, F19, F25: 3 known factors\n");
        printf ("    F16, F17, F18, F27, F30: 2 known factors\n");
        printf ("    F14, F21, F22, F23, F26, F28, F29: 1 known factor\n");
        printf ("\n");
        printf ("I cannot stress enough - if you are testing a newly discovered factor, \n");
        printf ("do NOT use the -k or -kf flags!\n");
        printf ("\n");
        printf ("Other notes:\n");
        printf ("\n");
        printf ("    You cannot test F0 with cofact. (It doesn't need testing. Try cofact 0 if you don't believe me.)\n");
        printf ("    You cannot test F31 or greater with cofact. (Yet.)\n");
        printf ("    Testing F30 requires an x86 family processor with AVX-512 extensions.\n");
        printf ("    Using proof files for F21 and above is highly advisable. Proofs for F17 to F26 are available \n");
        printf ("    from:\n");
        printf ("    https://64ordle.au/fermat/ \n");
        printf ("\n");
        printf ("----------------------------------------------------------------------------------------------------\n");
    }
}

int main (int argc, char **argv) {
    int n;                          // N of the Fermat number
    int n_fact;                     // The number of factors entered
    unsigned long k;                // Always 1 for a Fermat number
    unsigned long exp;              // The fermat exponent: 2^n
    unsigned long base;             // The base to test: always 3
    unsigned long x;                // Number of Pepin test square/mod operations
    unsigned long m;                // Iteration counter for square/mod loop
    unsigned long m_progress;       // The next m at which to print progress
    unsigned long m_progress_inc;   // The m increment at which to report progress
    int digits;                     // Number of digits int the cofactor
    char *cof_s;                    // The cofactor as a string
    int threads;                    // Number of threads (cores) to use in gwnum library
    int verbose;                    // Flag to enable printing more information
    int super_verbose;              // Cathy's print all sorts of super verbose stuff to stdout
    int interim;                    // Flag to print interim residues
    int modc;                       // Flag to evaluate and print A mod C and B mod C
    int octal;                      // Flag to print S-H residues in octal
    int debug;                      // Flag to enable printing debug information
    int sep;                        // Flag to print a separator line at the end of the run
    int check_proof_res;            // Flag to enable checking the mprime proof file A residue
    int use_proof_res;              // Flag to enable using the mprime proof file A residue instead of calculating it
    int known_factors;              // Flag to enable using currently known prime factors for a given Fermat number
    long fseek_rtn;                 // Return value from fseek
    long ftell_rtn_0, ftell_rtn_1;  // Return value from ftell before and after fseek call
    int res_len;                    // The size of the proof file residue, in bytes
    char cmdline[CMD_LEN];          // The reconstructed command line
    char line[1024];                // Temp string
    int argi, rtn, i, z;
    char *flags;                    // Pointer for multiple flags in one argument; z if file location to follow

    // Various time variables
    static struct timeval tv_start, tv_stop, tv_progress_start, tv_progress_stop;
    float wall_time, ms_per_iter;
    int wall_hours, wall_mins, wall_secs;

    time_t current_time;
    struct tm *time_block;
    char time_string[TIME_STRING_LEN];

    // gwnum library variables
    gwhandle gwdata;                // Structure for gwlib information
    gwnum r_gw;                     // The square/mode residue
    int gwerr;                      // Error value returned by some gwnum library calls
    double maxerr;                  // The maximum roundoff error returned by gw_get_maxerr

    size_t r_bin_buf_len;           // Number of longs in r_bin buffer
    unsigned long *r_bin;           // Binary array for tranfer of residue from GWNUM to GMP
    int len;                        // Temp

    mpz_t fact[N_FACT];             // The known factors of the Fermat number
    mpz_t Fm1;                      // The Fermat number - 1
    mpz_t F;                        // The Fermat number
    mpz_t R;                        // The Pepin residue, later the final Suyama residue
    mpz_t A;                        // The A residue
    mpz_t B;                        // The B residue
    mpz_t P;                        // The product of the known factors
    mpz_t Pm1;                      // The product of the known factors minus one
    mpz_t C;                        // The remaining cofactor
    mpz_t three;                    // The base 3
    mpz_t A_proof;                  // The proof file residue
    mpz_t tmp;                      // Temp

    char proof_file_name[NAME_LEN]; // Name of the proof file to read and (check or use)
    FILE *fp_proof;                 // Proof file
    int version, hashsize;          // VERSION and HASHSIZE values from the proof file
    char power_s[64];               // POWER string from the proof file
    char proof_desc_s[2048];        // The proof description string: (Fn)/factor_1/factor_2...
    char newline[2];                // Required to avoid the description fscanf from eating part of the residue
    int n_proof;                    // N of the Fermat number in the proof file
    int proof_power, proof_power_mult;  // Proof power and multiplier in the proof file
    long fseek_offset;              // Offset to seek to the proof residue in the proof file
    unsigned char *A_proof_raw;     // Buffer for the proof file raw residue

    // Start the wall time timer
    (void) gettimeofday(&tv_start, (struct timezone *) NULL);

    // Print compile time program information
    printf ("Program to check the primality of a Fermat number and its cofactor: %s, Version %s (%s %s)\n", prog_name, prog_vers, build_date, build_time);

    // Print date and time the program was started
    current_time = time(NULL);
    time_block = localtime(&current_time);
    strftime(time_string, TIME_STRING_LEN, "%A %d %B %Y %X", time_block);
    printf ("Run started: %s\n", time_string);
    printf ("\n");

    // Print the command line
    bzero(cmdline, sizeof(cmdline));
    for (argi=0; argi<argc; argi++) {
        if ((strlen(cmdline) + strlen(argv[argi])) > (CMD_LEN-1)) break;
        strcat (cmdline, argv[argi]);
        strcat (cmdline," ");
    }
    printf ("Command line: %s\n\n", cmdline);

    // Initialize GMP variables
    for (i=0; i<=N_FACT; i++) mpz_init (fact[i]);
    mpz_init (Fm1);
    mpz_init (F);
    mpz_init (R);
    mpz_init (A);
    mpz_init (B);
    mpz_init (P);
    mpz_init (Pm1);
    mpz_init (C);
    mpz_init (three);
    mpz_init (A_proof);
    mpz_init (tmp);

    mpz_init (mask64);
    mpz_init (r64);

    mpz_set_ui (mask64, 0xffffffffffffffffL);
    mpz_set_ui (three, 3L);

    // Parse command line parameters
    threads = 1;            // Default to 1 thread
    verbose = 0;            // Default to no verbose
    super_verbose = 0;      // Default to no super verbose
    interim = 0;            // Default to print no interim residues
    modc = 0;               // Default to not evaluate A mod C and B mod C
    octal = 0;              // Default to decimal representation of S-H residues
    debug = 0;              // Default to no debug
    sep = 0;                // Default to no separator line
    check_proof_res = 0;    // Default to not checking
    use_proof_res = 0;      // Default to calculating the A residue
    known_factors = 0;      // Default to only performing a Pepin test if no factors have been declared
    m_progress_inc = 0;     // Default of 0 will be changed to 10% of the run
    n = 0;                  // Invalid value, to make sure n is later set
    z = 0;                  // Flag for combined menu options requiring a file parameter (-c and -u)

    // Parse command line arguments starting with "-" args
    // The following loop will exit when first non "-" argument is found
    for (argi = 1; argi < argc; argi++) {
        if ((strcmp(argv[argi], "-cpr") == 0) || (strcmp(argv[argi], "-CPR") == 0)) {
            check_proof_res = 1;
            argi++;
            strncpy (proof_file_name, argv[argi], NAME_LEN-1);
        } else
        if ((strcmp(argv[argi], "-sv") == 0) || (strcmp(argv[argi], "-SV") == 0)) {       // -sv turns on a lot of flags! Must be a separate flag
            debug = 1;
            interim = 1;
            modc = 1;
            octal = 1;
            sep = 1;
            verbose = 1;
            super_verbose = 1;
        } else
        if ((strcmp(argv[argi], "-p") == 0) || (strcmp(argv[argi], "-P") == 0)) {
            argi++;
            m_progress_inc = atol(argv[argi]);
        } else
        if ((strcmp(argv[argi], "-sep") || (strcmp(argv[argi], "-SEP") == 0)) == 0) {
            sep = 1;
        } else
        if ((strcmp(argv[argi], "-t") == 0) || (strcmp(argv[argi], "-T") == 0)) {
            argi++;
            threads = atoi(argv[argi]);
        } else
        if ((strcmp(argv[argi], "-upr") == 0) || (strcmp(argv[argi], "-UPR") == 0)) {
            use_proof_res = 1;
            argi++;
            strncpy (proof_file_name, argv[argi], NAME_LEN-1);
        } else
        if ((strcmp(argv[argi], "-kf") == 0) || (strcmp(argv[argi], "-KF") == 0)) {
            known_factors = 1;
        } else
        if (strncmp(argv[argi], "-", 1) == 0) {     // Combined -cdvhikmou flags, processed in that order
            z = 0;
            flags = strpbrk(argv[argi], "cCdDvVhHiIkKmMoOuU");      // We are somewhat tolerant of upper case
            if (flags != NULL) {
                flags = strpbrk(argv[argi], "cC");   // increment z to ensure we get a file argument
                if (flags != NULL) {
                    check_proof_res = 1;
                    z++;
                }
                flags = strpbrk(argv[argi], "dD");
                    if (flags != NULL) {
                    debug = 1;
                }
                flags = strpbrk(argv[argi], "vV");   // processing verbose flag precedes help, to display custom help
                if (flags != NULL) {
                    verbose = 1;
                }
                flags = strpbrk(argv[argi], "hH");
                if (flags != NULL) {
                    usage (verbose);
                    exit (0);
                }
                flags = strpbrk(argv[argi], "iI");
                if (flags != NULL) {
                    interim = 1;
                }
                flags = strpbrk(argv[argi], "kK");
                if (flags != NULL) {
                    known_factors = 1;
                }
                flags = strpbrk(argv[argi], "mM");
                if (flags != NULL) {
                    modc = 1;
                }
                flags = strpbrk(argv[argi], "oO");
                if (flags != NULL) {
                    octal = 1;
                }
                flags = strpbrk(argv[argi], "uU");   // increment z to ensure we get a file argument
                if (flags != NULL) {
                    use_proof_res = 1;
                    z++;
                }
                flags = strpbrk(argv[argi], "aAeEgGjJlLnNpPqQrRsStTwWxXyYzZ1234567890"); // check if there were other letters in combined flag
                if (flags != NULL) {
                    printf ("Warning: unknown option in command line flag: %s\n", argv[argi]);
                    usage (0);
                    printf ("Ignoring unknown option and processing other flags\n");
                }
                if (z != 0) {
                    argi++;
                    strncpy (proof_file_name, argv[argi], NAME_LEN-1);
                }

            } else {
                printf ("Error: unknown command line flag: %s\n", argv[argi]);
                usage (0);
                exit (1);
            }
        } else {
            break;
        }
    }

    // Parse n of the Fermat number
    if (argi < argc) {
        if (sscanf (argv[argi], "%d", &n) != 1) {
            printf ("Error: unable to parse Fermat number: %s\n", argv[argi]);
            usage (0);
            exit (1);
        }
        argi++;
    } else {
        printf ("Error: must specify the Fermat number\n");
        usage (0);
        exit (1);
    }

    // Make sure the Fermat number is in the range supported by the gwnum library
    if (n < 0 || n > 30) {
        printf ("Error: cofact only supports F0 through F30. F%d was specified\n", n);
        exit (1);
    }

    // If F0 selected, print a message then exit
    if (n == 0) {
        printf ("The Pepin test cannot be run on Fermat number F0 = 3\n");
        printf ("F0 is prime!\n\n");
        goto fast_exit;
    }

    // Calculate the Fermat number F and F-1
    exp = 1 << n;                   // Exponent of 2 = 2^n
    mpz_set_ui (Fm1, 1L);           // Fm1 = 2^2^n
    mpz_mul_2exp (Fm1, Fm1, exp);   // "
    mpz_add_ui (F, Fm1, 1L);        // F = Fm1 + 1

    // If known factors flag is set, we initialise with the expected factors for a particular Fermat number and bypass user submitted factors
    if (known_factors && n > 11 && n < 33 && n != 20 && n != 24) {
        switch (n) {
            case 12:
                n_fact = 6; mpz_set_str(fact[0],"114689",10); mpz_set_str(fact[1],"26017793",10); mpz_set_str(fact[2],"63766529",10); mpz_set_str(fact[3],"190274191361",10); mpz_set_str(fact[4],"1256132134125569",10); mpz_set_str(fact[5],"568630647535356955169033410940867804839360742060818433",10);
                break;
            case 13:
                n_fact = 4; mpz_set_str(fact[0],"2710954639361",10); mpz_set_str(fact[1],"2663848877152141313",10); mpz_set_str(fact[2],"3603109844542291969",10); mpz_set_str(fact[3],"319546020820551643220672513",10);
                break;
            case 14:
                n_fact = 1; mpz_set_str(fact[0],"116928085873074369829035993834596371340386703423373313",10);
                break;
            case 15:
                n_fact = 3; mpz_set_str(fact[0],"1214251009",10); mpz_set_str(fact[1],"2327042503868417",10); mpz_set_str(fact[2],"168768817029516972383024127016961",10);
                break;
            case 16:
                n_fact = 2; mpz_set_str(fact[0],"825753601",10); mpz_set_str(fact[1],"188981757975021318420037633",10);
                break;
            case 17:
                n_fact = 2; mpz_set_str(fact[0],"31065037602817",10); mpz_set_str(fact[1],"7751061099802522589358967058392886922693580423169",10);
                break;
            case 18:
                n_fact = 2; mpz_set_str(fact[0],"13631489",10); mpz_set_str(fact[1],"81274690703860512587777",10);
                break;
            case 19:
                n_fact = 3; mpz_set_str(fact[0],"70525124609",10); mpz_set_str(fact[1],"646730219521",10); mpz_set_str(fact[2],"37590055514133754286524446080499713",10);
                break;
            case 21:
                n_fact = 1; mpz_set_str(fact[0],"4485296422913",10);
                break;
            case 22:
                n_fact = 1; mpz_set_str(fact[0],"64658705994591851009055774868504577",10);
                break;
            case 23:
                n_fact = 1; mpz_set_str(fact[0],"167772161",10);
                break;
            case 25:
                n_fact = 3; mpz_set_str(fact[0],"25991531462657",10); mpz_set_str(fact[1],"204393464266227713",10); mpz_set_str(fact[2],"2170072644496392193",10);
                break;
            case 26:
                n_fact = 1; mpz_set_str(fact[0],"76861124116481",10);
                break;
            case 27:
                n_fact = 2; mpz_set_str(fact[0],"151413703311361",10); mpz_set_str(fact[1],"231292694251438081",10);
                break;
            case 28:
                n_fact = 1; mpz_set_str(fact[0],"1766730974551267606529",10);
                break;
            case 29:
                n_fact = 1; mpz_set_str(fact[0],"2405286912458753",10);
                break;
            case 30:
                n_fact = 2; mpz_set_str(fact[0],"640126220763137",10); mpz_set_str(fact[1],"1095981164658689",10);
                break;
/*   Future planning: later versions of gwnum may support F31 and F32. If not, we can at least hope! CXC
            case 31:
                n_fact = 1; mpz_set_str(fact[0],"46931635677864055013377",10);
                break;
            case 32:
                n_fact = 1; mpz_set_str(fact[0],"25409026523137",10);
                break;
*/
        }
        printf ("Using the following known factors for F%d: ", n);
        for (i = 0; i < n_fact; i++) {
            mpz_out_str (stdout, 10, fact[i]);
            printf (" ");
        }
        printf ("\n");
    } else {
        // Parse the user submitted factors, and check that they divide the Fermat number
        n_fact = argc - argi;
        for (i = 0; i < n_fact; i++) {
            if (mpz_set_str(fact[i], argv[argi], 10) != 0) {
                printf ("Error: cannot parse factor: %s\n", argv[argi]);
                exit (1);
            }
            mpz_tdiv_r (tmp, F, fact[i]);       // tmp = F mod fact[i]
            if (mpz_cmp_ui (tmp, 0L) != 0) {
                printf ("Error: supplied factor does not divide F%d: %s\n", n, argv[argi]);
                exit (1);
            }
            argi++;
        }
    }

    // If checking or using a proof file residue is enabled, read the proof file
    if (check_proof_res && use_proof_res) {
        printf ("Error: Can only specify one of -cpr and -upr\n");
        exit (1);
    }

    if (check_proof_res || use_proof_res) {
        printf ("Reading residue from proof file: %s\n", proof_file_name);

        if ((fp_proof = fopen (proof_file_name, "rb")) == NULL) {               // The "b" is not needed according to fopen man page
            printf ("Error: Cannot open proof file: %s\n", proof_file_name);
            exit (1);
        }

        if (fscanf (fp_proof, "PRP PROOF\n") != 0) {
            printf ("Error: Cannot read PRP PROOF from proof file header\n");
            exit (1);
        }
        if (fscanf (fp_proof, "VERSION=%d\n", &version) != 1 || (version != 1 && version != 2)) {
            printf ("Error: Cannot read VERSION number from proof file header\n");
            exit (1);
        }
        if (fscanf (fp_proof, "HASHSIZE=%d\n", &hashsize) != 1 || hashsize < 32 || hashsize > 64) {
            printf ("Error: Cannot read HASHSIZE value from proof file header\n");
            exit (1);
        }
        if (fscanf (fp_proof, "POWER=%s\n", &power_s) != 1) {
            printf ("Error: Cannot read POWER string from proof file header\n");
            exit (1);
        }
        if (fscanf (fp_proof, "NUMBER=%2047[^\n]%1[\n]", proof_desc_s, newline) != 2) {
            printf ("Error: Cannot read proof description string from proof file header\n");
            exit (1);
        }

        printf ("Proof file description: %s\n", proof_desc_s);

        // Parse the Fermat number exponent from the proof file. Could be F# or (F#).
        if (sscanf (proof_desc_s, "F%d", &n_proof) != 1) {
            if (sscanf (proof_desc_s, "(F%d)", &n_proof) != 1) {
                printf ("Error: Cannot read proof description string from proof file header\n");
                exit (1);
            }
        }

        // Allocate a buffer of 2^n / 8 bytes to store the raw A residue
        res_len = 1 << (n_proof - 3);
        if ((A_proof_raw = calloc (res_len+1, sizeof (unsigned char))) == NULL) {
            printf ("Error: Unable to allocate buffer for proof file residue\n");
            exit (1);
        }

        // Parse the Proof Power from the proof file. Supported formats are "#" and "#x2".
        // If proof power is "#x2" then seek to the position in the file of the second proof.
        // If proof power is "#" then no seek is required.
        if (debug) printf ("Proof file power: %s\n", power_s);
        if (sscanf (power_s, "%dx%d", &proof_power, &proof_power_mult) == 2) {
            if (proof_power >= 5 && proof_power <= 9 && proof_power_mult == 2) {
                fseek_offset = (proof_power + 1) * res_len;

                if (debug) printf ("Calling fseek (fp_proof, offset = %lx, SEEK_CUR)\n", fseek_offset);
                ftell_rtn_0 = ftell (fp_proof);
                fseek_rtn   = fseek (fp_proof, fseek_offset, SEEK_CUR);
                ftell_rtn_1 = ftell (fp_proof);
                if (fseek_rtn != 0 || (ftell_rtn_1 - ftell_rtn_0) != fseek_offset) {
                    printf ("Error: seek to second proof in proof file failed\n");
                    printf ("    fseek_offset = %ld, fseek_rtn = %ld, ftell_rtn_0 = %ld, ftell_rtn_1 = %ld\n", fseek_offset, fseek_rtn, ftell_rtn_0, ftell_rtn_1);
                    exit (1);
                }
            } else {
                printf ("Error: proof power or proof power multiplier not supported. POWER string = \"%s\", power = %d, mult = %d\n", power_s, proof_power, proof_power_mult);
                exit (1);
            }
        }

        // Read the A residue from the proof file
        if ((rtn = fread (A_proof_raw, 1, res_len, fp_proof)) != res_len) {
            printf ("Error: Cannot read residue from proof file. Returned %d\n", rtn);
            exit (1);
        }
/*
        printf ("Proof file residue: \n");
        for (i=0; i<16; i++) {
            printf ("%02x ", A_proof_raw[i]);
        }
        printf ("\n");
*/
        if (debug) {
            printf ("Proof file A residue LSBs: \n");
            for (i=0; i<16; i++) {
                printf ("%02x ", A_proof_raw[i]);
            }
            printf ("\n");
        }

        mpz_import (A_proof, res_len, -1, sizeof (unsigned char), 0, 0, A_proof_raw);

//      print_mpz (A_proof, 16, "A_proof");
        if (super_verbose) {
            printf ("\n");
            print_mpz (A_proof, 16, "A_proof");
        }
        free (A_proof_raw);

        printf ("\n");
    }


    // If "use proof residue" enabled, skip the A calc steps; othwise perform them
    if (use_proof_res) {
        printf ("Using A residue from proof file instead of calculating it\n");
        printf ("Skipping the Pepin test\n\n");
        mpz_set (A, A_proof);
    } else {
        // If not using proof file residue, do the full Pepin and Suyama calculations
        printf ("Testing F%d for primality using the Pepin test\n", n);
        printf ("Using %d threads in gwnum library\n", threads);
        fflush (stdout);

        k = 1;                  // K for modulo value

        if (debug) printf ("Calling gwinit (gwhandle = %p)\n", &gwdata); 
        gwinit (&gwdata);                                       // Initialize the gwnum handle

        if (debug) printf ("Calling gwset_num_threads (gwhandle = %p, num_threads = %ld)\n", &gwdata, (unsigned long) threads); 
        gwset_num_threads (&gwdata, (unsigned long) threads);   // Set number of threads to use

        if (debug) printf ("Calling gwset_safety_margin (gwhandle = %p, safety_margin = %lf)\n", &gwdata, (double) 2.0); 
        gwset_safety_margin (&gwdata, (double) 2.0);            // Had to set this to 3 in pmfs to prevent calc errors with very large N

        if (debug) printf ("Calling gwsetup (gwhandle = %p, k = %lf, b = %ld, n = %ld, c = %ld)\n", &gwdata, (double) k, 2L, exp, 1L); 
        gwerr = gwsetup (&gwdata, (double) k, 2L, exp, 1L);     // Setup to use modulo F = 2^2^n + 1
                                                                // Note that K is double, so only values <= 53 bits can be represented. GWNUM checks for this.
        if (gwerr) {
            if (gwerr == 1002) {
                printf ("gwsetup error = 1002 (Number too large for the FFTs)\n");
                if (n == 30) printf ("Note that gwnum requires an AVX512 computer to support F30\n");
            } else {
                printf ("gwsetup error = %d\n", gwerr);
            }
            exit (1);
        }

       gwsetnormroutine (&gwdata, 0, 1, 0);                     // Set flag to enable round-off error checking
                                                                // This call must be AFTER gwsetup
        if (verbose) {
            gwfft_description (&gwdata, line);
            printf ("fft_description: %s\n", line);
            printf ("fftlen = %ld\n", gwfftlen (&gwdata));
            printf ("near_fft_limit = %d\n", gwnear_fft_limit (&gwdata, (double)3.0));
            printf ("\n");
        }

        r_gw = gwalloc (&gwdata);                               // Allocate a GW number for the residue
        if (r_gw == NULL) {
            printf ("gwalloc for r_gw failed\n");
            exit (1);
        }

        // Initialize r_gw = base for Pepin test = 3
        base = 3;
        binary64togw (&gwdata, &base, 1L, r_gw);

        gw_clear_maxerr (&gwdata);

        // Create buffer for transfer of residues from GWNUM to GMP
        r_bin_buf_len = exp / 64 + 1;
        r_bin = (unsigned long *) calloc (r_bin_buf_len, sizeof (unsigned long));
    /*
        len = gwtobinary64 (&gwdata, r_gw, r_bin, r_bin_buf_len);
        printf ("base = %2ld, r_gw = %016lx %016lx\n", base, r_bin[1], r_bin[0]);
    */

        x = exp - 1;                                            // Number of Pepin test square/mod steps: x = 2^n - 1

        // If the progress print increment has not been set and the test is likely to take more than a second (at least 100000 steps), set it by default to 10% of the run
        if (m_progress_inc == 0 && x > 100000) m_progress_inc = x / 10;                // Default to 10% of the run

        m_progress = m_progress_inc;
        (void) gettimeofday(&tv_progress_start, (struct timezone *) 0);

        // Almost all the runtime is in the following loop
        for (m = 1; m <= x; m++) {
            if (m < 24) {                                               // FIXME Good for n <= 2^24? Could this be set more intelligently?
                gwsquare2_carefully (&gwdata, r_gw, r_gw);              // r_gw = (r_gw ^ 2) mod F
            } else {
//              gwsquare2 (&gwdata, r_gw, r_gw);                        // r_gw = (r_gw ^ 2) mod F      Use this line when using gwnum from mprime v29.8
                gwsquare2 (&gwdata, r_gw, r_gw, 0);                     // r_gw = (r_gw ^ 2) mod F      Use this line when using gwnum from mprime v30.8
                                                                        // NOTE, gwnum 30.8 has extra options requiring additional variable set to 0; see gwnum.h (CX Cowie)
            }

            maxerr = gw_get_maxerr (&gwdata);
            if (maxerr >= 0.45) {
                printf ("Roundoff warning: k = %ld, n = %d, m = %ld, maxerr = %22.20lf\n", k, n, m, maxerr);
                gw_clear_maxerr (&gwdata);
            }

            if (m_progress_inc > 0 && m >= m_progress) {
                (void) gettimeofday(&tv_progress_stop, (struct timezone *) 0);
                wall_time = tv_secs(tv_progress_stop) - tv_secs(tv_start);
                wall_hours = wall_time / 3600;
                wall_mins = (wall_time - (wall_hours * 3600)) / 60;
                wall_secs = (wall_time - (wall_hours * 3600) - (wall_mins * 60));
                ms_per_iter = (tv_msecs(tv_progress_stop) - tv_msecs(tv_progress_start)) / m_progress_inc;
                printf ("Iteration: %9ld / %9ld (%5.1f%%), ms/iter: %7.3lf, Wall time = %d:%02d:%02d (HH:MM:SS)\n", m, x, 100.0 * m / x, ms_per_iter, wall_hours, wall_mins, wall_secs);
                fflush (stdout);
                m_progress += m_progress_inc;
                tv_progress_start.tv_sec  = tv_progress_stop.tv_sec;
                tv_progress_start.tv_usec = tv_progress_stop.tv_usec;
            }
            if (interim) {
                if ((n == 17 && m == 20) || (n == 8 && m == 246)) {
                    len = gwtobinary64 (&gwdata, r_gw, r_bin, r_bin_buf_len);
                    mpz_import (R, len, -1, 8, 0, 0, r_bin);
                    printf ("Iteration: %9ld\n", m);
                    digits = mpz_sizeinbase (R, 10);
                    cof_s = malloc (digits + 2);
                    mpz_get_str (cof_s, 10, R);
                    digits = strlen (cof_s);
                    if (super_verbose || digits < 600) {
                        print_mpz (R, 10, "R");
                        printf ("\n");
                    }
                    print_residues (R, octal, "Interim Pepin");
                    fflush (stdout);
                }
                if (n == 22 && (m == 126000 || m == 354000 || m == 486000 || m == 790000 || m == 1078000 || m == 1430000 || m == 1854000 || m == 2390000 || m == 2718000 || m == 3046000 || m == 3542000 || m == 3838000 || m == 4182000)) {
                    printf ("Iteration: %9ld /   4194303 ", m);
                    len = gwtobinary64 (&gwdata, r_gw, r_bin, r_bin_buf_len);
                    mpz_import (R, len, -1, 8, 0, 0, r_bin);
                    print_residues (R, octal, "Interim");
                    fflush (stdout);
                }
            }
        }

        // Check for errors
        gwerr =  gw_test_for_error (&gwdata);
        if (gwerr) {
            printf ("Error: gw_test_for_error = %d\n", gwerr);
            exit (1);
        }

        // Convert Pepin residue r_gw to r_bin to R
        len = gwtobinary64 (&gwdata, r_gw, r_bin, r_bin_buf_len);
        mpz_import (R, len, -1, 8, 0, 0, r_bin);

        if (verbose) {
            switch (len) {
                case 1:
                    printf ("Pepin residue: %016lx\n", r_bin[0]);
                    break;
                case 2:
                    printf ("Pepin residue: %016lx %016lx\n", r_bin[1], r_bin[0]);
                    break;
                default:
                    printf ("Pepin residue: length = %d, %016lx ... %016lx %016lx\n", len, r_bin[len-1], r_bin[1], r_bin[0]);
            }
        }
        if (super_verbose) {
            printf ("\n");
            print_mpz (R, 10, "R");
        }

        print_residues (R, octal, "Pepin");

        if (mpz_cmp (R, Fm1) == 0) {
            printf ("F%d is prime!\n", n);
        } else {
            printf ("F%d is composite\n", n);
        }
        printf ("\n");

        // Square/mod one more time to get A. This is the mprime proof file residue.
//      gwsquare2 (&gwdata, r_gw, r_gw);        // r_gw = (r_gw ^ 2) mod F      Use this line when using gwnum from mprime v29.8
        gwsquare2 (&gwdata, r_gw, r_gw, 0);     // r_gw = (r_gw ^ 2) mod F      Use this line when using gwnum from mprime v30.8
                                                // NOTE, gwnum 30.8's gwsquare2 has extra options requiring additional variable set to 0; see gwnum.h (CX Cowie)
        len = gwtobinary64 (&gwdata, r_gw, r_bin, r_bin_buf_len);
        mpz_import (A, len, -1, 8, 0, 0, r_bin);

        if (verbose) {
            switch (len) {
                case 1:
                    printf ("Suyama A residue: %016lx\n", r_bin[0]);
                    break;
                case 2:
                    printf ("Suyama A residue: %016lx %016lx\n", r_bin[1], r_bin[0]);
                    break;
                default:
                    printf ("Suyama A residue: length = %d, %016lx ... %016lx %016lx\n", len, r_bin[len-1], r_bin[1], r_bin[0]);
            }
        }

        if (check_proof_res) {
            if (mpz_cmp (A, A_proof) == 0) {
                printf ("Calculated A residue matches proof file residue\n\n");
            } else {
                printf ("Error: Calculated A residue does not matches proof file residue\n\n");
                exit (1);
            }
        }

        gwfree (&gwdata, r_gw);                 // Free the GW number: GW docs do not make it clear when this is needed
        gwdone (&gwdata);                       // Free all GW data
    }

    // If known factors were provided, perform the Suyama test to determine whether the remaining cofactor C is prime or composite
    if (n_fact > 0) {
        printf ("Testing the F%d cofactor for primality using the following known factors: ", n);
        for (i = 0; i < n_fact; i++) {
            mpz_out_str (stdout, 10, fact[i]);
            printf (" ");
        }
        printf ("\n");

        // Calculate P = product of the known factors
        mpz_set_ui (P, 1L);
        for (i = 0; i < n_fact; i++) {
            mpz_mul (P, P, fact[i]);
        }
//      print_mpz (P, 10, "P");

        // Calculate the cofactor C = F / P
        mpz_div (C, F, P);
        digits = mpz_sizeinbase (C, 10);
        cof_s = malloc (digits + 2);
        mpz_get_str (cof_s, 10, C);
        digits = strlen (cof_s);

        if (super_verbose || digits < 600) {
            printf ("Cofactor (%d digits): ", digits);
            mpz_out_str (stdout, 10, C);
                if (super_verbose) {
                    printf ("\nBinary representation:\n");
                    mpz_out_str (stdout, 2, C);
                }
            printf ("\n");
        } else {
            printf ("Cofactor is %d digits long\n", digits);
        }

        print_residues (A, octal, "A");
        if (modc) {
            mpz_mod (A, A, C);              // A mod C
            print_residues (A, octal, "A mod C");
        }
        fflush (stdout);

        // Calculate B = 3^(P-1) mod F
        mpz_sub_ui (Pm1, P, 1L);
        mpz_powm (B, three, Pm1, F);

        print_residues (B, octal, "B");
        if (modc) {
            mpz_mod (B, B, C);              // B mod C
            print_residues (B, octal, "B mod C");
        }

        // Calculate R = (A - B) mod C
        mpz_sub (R, A, B);                  // R = A - B
        mpz_mod (R, R, C);                  // R = (A - B) mod C

        print_residues (R, octal, "(A-B) mod C");

        if (mpz_cmp_ui (R, 0L) == 0) {
            printf ("F%d cofactor is prime!\n", n);
        } else {
            mpz_sub (R, A, B);              // R = A - B
            mpz_gcd (R, R, C);              // R = GCD ((A-B), C)
            if (mpz_cmp_ui (R, 1L) == 0) {
                printf ("F%d cofactor is composite, and is not a prime power (GCD of A-B, C = 1)\n", n);
            } else {
                printf ("F%d cofactor is composite, and is also a prime power\n", n);   // Probably unlikely to ever reach this code
                print_mpz (R, 10, "GCD of A-B, C");
            }
        }
        printf ("\n");
    }

fast_exit:
    // Print the date and time the program ended and the total wall time
    current_time = time(NULL);
    time_block = localtime(&current_time);
    strftime(time_string, TIME_STRING_LEN, "%A %d %B %Y %X", time_block);

    (void) gettimeofday(&tv_stop, (struct timezone *) 0);
    wall_time = tv_secs(tv_stop) - tv_secs(tv_start);
    wall_hours = wall_time / 3600;
    wall_mins = (wall_time - (wall_hours * 3600)) / 60;
    wall_secs = (wall_time - (wall_hours * 3600) - (wall_mins * 60));

    printf ("Run ended: %s, Wall time = %d:%02d:%02d (HH:MM:SS)\n\n", time_string, wall_hours, wall_mins, wall_secs);

    if (sep) printf ("----------------------------------------------------------------------------------------------------\n");
}

