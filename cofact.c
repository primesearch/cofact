/*
 * Test a small Fermat number for primality. (Small means, up to 320 million digits in size!)
 *
 * If known factors are given, then the cofactor is tested for probable primality.
 *
 * Authors: Gary B. Gostin
 *          Catherine X. Cowie (1catherine dot cowie at gmail dot com)
 *
 * Copyrights: this program is (C) 2023-2024 Gostin and Cowie under the Creative Commons Zero
 *             licence, we will not be responsible for whether you find this work useful, or whether
 *             it opens a portal to another dystopian dimension where your computer used to be.
 *
 *             the gwnum library is (C) 2002-24 Mersenne Research, Inc. All rights reserved.
 *
 *             the GMP library is (C) 1991, 1993-2016, 2018-2024 Free Software Foundation, Inc.
 *
 * Values: F is the Fermat number, 2^2^m + 1 = Q x C, Q is the product of known prime factors, 
 * C is the remaining cofactor. The exponent m produces huge untestable Fermats beyond m = 30.
 *
 * Mersenne numbers of similar magnitude (2^p - 1, where p is an odd prime below 2^30) are also
 * supported.
 *
 * Prints Res64 (hexadecimal) and Selfridge-Hurwitz residues (decimal, optionally octal and hex) 
 * on each step (Pepin, Suyama A, B, and S) to compare with other programs.
 *
 * The steps for a Fermat number are:
 *   Pepin Fermat test:                     If (and only if) P == -1 mod F and
 *      P == b^((F-1)/2) mod F              Jacobi (b/F) = -1, then F is prime.
 *   Suyama cofactor test:
 *      A == P^2 mod F = b^(F-1) mod F      Prime95/mprime type 5 residue, also result of a Fermat-PRP test.
 *      B == b^(Q-1) mod F
 *      S == (A - B) mod C                  Cofactor C is composite if S =/= 0
 *                                          If S == 0, C is probably prime to the base b^Q.
 *      GCD (A - B, C)                      Cofactor C is not a prime power if GCD (A - B, C) = 1
 *
 * Here and elsewhere in comments, == means "congruent to, modulo some number" rather than equality.
 *
 * cofact can be run in one of three modes:
 *   mode 1 (default):  Test a Fermat number for primality using the Pepin test.
 *                      Then, if known factors are provided, use the Pepin residue to perform the 
 *                      Suyama PRP test on the cofactor.
 *   mode 2 (-cpr):     Perform all steps in mode 1. Also, compare the Suyama A residue calculated 
 *          (or -c)     by cofact to the A residue read from a proof file generated by mprime 
 *                      when testing the same cofactor.
 *   mode 3 (-upr):     Read the Suyama A residue for a Fermat number from a mprime proof file 
 *          (or -u)     and after testing it is correct, perform the Suyama test on the cofactor.
 *
 * This same general method can be adapted for Mersenne numbers. Here we don't have a definitive 
 * primality test (this is not Lucas - Lehmer!), but a Fermat PRobable-Primality (PRP) test:
 *   Fermat-PRP test and Suyama A value:
 *      A == b^(M-1) mod M                  If A == 1 mod M, then M = 2^p - 1 is probably prime
 *    M-1 = 2^p - 2, so after p squarings a modular division by b^2 is required to obtain A. 
 * If a proof is used, this typically contains the A.b^2 residue prior to modular division.
 *
 * There is some limited error checking using Gerbicz's integrity test for PRP tests on numbers
 * with known prime factors q, which has a 1/q likelihood of error (which is small for large q).
 *
 * Some future nice things to consider adding: full Gerbicz error checking, proof generation or
 * validation, and giving everyone a unicorn.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>
#include <locale.h>

#include <errno.h>
#include <gmp.h>

#include "gwnum.h"

#define CMD_LEN 2048        // Length of the command line string supports factors of 
                            // sizes up to the F12 cofactor or thereabouts, which is 1,133 digits
#define NAME_LEN 64         // Length of the proof filename. Please use short, sensible filenames.
#define TIME_STRING_LEN 64
#define N_FACT 15           // Maximum Fermat/Mersenne factors supported (M726064763 has 12 known)
#define K_FACT 6            // Largest number of prime factors known for a particular Fermat (F12)

#define tv_secs(tv) (tv.tv_sec + tv.tv_usec / 1000000.0)
#define tv_msecs(tv) (tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0)

const char *prog_name  = "cofact";
const char *prog_vers  = "0.74c";
const char *build_date = __DATE__;
const char *build_time = __TIME__;

mpz_t mask64;       // 64 bit mask for print_residues
mpz_t r64;          // 64 LSBs of a residue

// Print the label followed by Res64 (hex), Res 2^36 (decimal), Res 2^36-1 (decimal), Res 2^35-1 (decimal), and possibly other bases
void print_residues (mpz_t m, int binary, int fnumber, char *name) {
    unsigned long res64, res36, res36m1, res35m1;
    unsigned long value;

    value = 0;
    mpz_and (r64, m, mask64);
    res64 = mpz_get_ui (r64);
    res36   = mpz_tdiv_ui (m, 0x1000000000L);
    res36m1 = mpz_tdiv_ui (m,  0xFFFFFFFFFL);
    res35m1 = mpz_tdiv_ui (m,  0x7FFFFFFFFL);
    wchar_t *pe;
    pe = (wchar_t *) malloc(sizeof(wchar_t) * 2);
    pe[0] = 0x00e9;
    pe[1] = 0;
    setlocale(P_ALL, "");
    if (strcmp(name, "Interim") == 0) value = 1;
    if (strcmp(name, "Pepin") == 0) value = 2;
    switch (value) {
        case 1: printf(" "); break;
        case 2: printf ("      P%lspin ", pe); break;
        default: printf ("%s ", name);
    }
    if (fnumber == 0) printf ("residue mod M: 0x%09lX %10ld", res64, res36);
    else if (fnumber < 6) printf ("residue mod F%d: 0x%09lX %10ld", fnumber, res64, res36);
    else printf ("residue: 0x%016lX |  %11ld  %11ld  %11ld", res64, res36, res36m1, res35m1);
    if (binary > 3) {printf (" (decimal)\n");} else {printf ("\n");}
    if ((binary & 8) == 8) {
        switch (value) {
            case 1: printf("            "); break;
            case 2: printf ("      P%lspin ", pe); break;
            default: printf ("%s ", name);
        }
        if (fnumber == 0) printf ("residue mod M: %11lo (octal)\n", res64);
        else if (fnumber < 6) printf ("residue mod F%d: %11lo (octal)\n", fnumber, res64);
        else printf ("residue: 0x%016lX | %012lo %012lo %012lo (octal)\n", res64, res36, res36m1, res35m1);
    }
    if (fnumber > 5 && (binary & 16) == 16) {
        switch (value) {
            case 1: printf("            "); break;
            case 2: printf ("      P%lspin ", pe); break;
            default: printf ("%s ", name);
        }
        printf ("residue: 0x%016lX |  0x%09lX  0x%09lX  0x%09lX (hexadecimal)\n", res64, res36, res36m1, res35m1);
    }
    if ((binary & 2) == 2) {
        switch (value) {
            case 1: printf("            "); break;
            case 2: printf ("P%lspin ", pe); break;
            default: printf ("%s ", name);
        }
        if (fnumber != 0) printf ("residue mod F%d: ", fnumber); else printf ("residue ");
        mpz_out_str (stdout, 2, m);
        printf (" (binary)\n");
    }
}

// Print an mpz_t number with a label
void print_mpz (mpz_t m, int pbase, char *name) {

    printf ("%s = ", name);
    mpz_out_str (stdout, pbase, m);
    printf ("\n");
}

// Return the number of digits in the number
int num_digits (mpz_t num) {
    size_t digits;
    char *num_s;                            // The number as a string

    digits = mpz_sizeinbase (num, 10);      // May be one too large
    num_s = malloc (digits + 2);
    mpz_get_str (num_s, 10, num);
    digits = strlen (num_s);
    free (num_s);

    return (int) digits;
}

void usage (int verbose) {
    wchar_t *pe;
    pe = (wchar_t *) malloc(sizeof(wchar_t) * 2);
    pe[0] = 0x00e9;
    pe[1] = 0;
    setlocale(P_ALL, "");
    if (verbose == 0) {
    printf ("Basic usage:          run a P%lspin test, followed by a Suyama cofactor test if factors are supplied.\n\n", pe);
    printf ("Default (mode 1):     cofact                  Fermat_exponent  [factor_1  factor_2 ...]\n");
    printf ("Mode 2:               cofact  -cpr  filename  Fermat_exponent  [factor_1  factor_2 ...]\n");
    printf ("Mode 3:               cofact  -upr  filename  Fermat_exponent  [factor_1  factor_2 ...]\n\n");
    printf ("    Fermat_exponent   Should be a whole number from 1 to 30\n");
    printf ("    factor(s)         Whole number(s) dividing a Fermat number F = 2^2^m + 1, m < 31\n\n");
    printf ("Flags:  -c, -cpr      Checks results against a verifiable delay function (VDF) proof file.\n");
    printf ("        -u, -upr      Skips P%lspin test, and uses a VDF proof file for the Suyama test only.\n", pe);
    printf ("        -b, -o, -x    Binary, Octal, or heXadecimal output\n");
    printf ("        -a, -i        All or interim residues printed\n");
    printf ("        -d, -v, -sv   Print debug, verbose, or super-verbose information\n");
    printf ("        -h, --help    This basic help\n");
    printf ("        -k            Use known Fermat factors\n");
    printf ("                  **  Do NOT use -k if you believe you have a new Fermat factor to test.   **\n");
    printf ("        -t threads    Specifies the number of threads to use in the gwnum library. Defaults to 1.\n");
    printf ("        -y            Run Fermat-PRP or cofactor tests on a Mersenne number M = 2^p - 1, p > 30\n");
    printf ("                      This flag is optional but if used it must immediately precede the exponent.\n");
    printf ("        -z base       Use a different base for the P%lspin test\n\n", pe);
    printf ("                      Flags modifying cofact's operation should always precede the exponent.\n\n");
    printf ("More verbose help is available:    cofact -hv | more\n\n");
    } else {
    printf ("  Usage:   cofact [-cpr|-c|-u|-upr filename]\n");
    printf ("                  [-a|-b|-d|-h|-i|-k|-m|-o|-v|-x|-j]\n");
    printf ("                  [-q|-w string]\n");
    printf ("                  [-p iterations]\n");
    printf ("                  [-sep]\n");
    printf ("                  [-t threads]\n");
    printf ("                  [-z base]\n");
    printf ("                  [-y]        Fermat_or_Mersenne_exponent    [factor_1 factor_2 ...]\n\n");
    printf ("  Default (mode 1) runs a P%lspin primality test or Fermat-PRP test, followed by a Suyama cofactor\n", pe);
    printf ("  test if factors are supplied.\n\n");
    printf ("    Fermat_exponent      Should be a whole number from 1 to 30\n");
    printf ("    factor(s)            Whole number(s) dividing a Fermat number F = 2^2^m + 1, m < 31\n\n");
    printf ("    Mersenne_exponent    Should be a whole number greater than 2\n");
    printf ("                         For exponents less than 31, -y must immediately precede the exponent.\n");
    printf ("    factor(s)            Whole number(s) dividing a Mersenne number M = 2^p - 1, p > 2\n");
    printf ("                         Up to 15 factors are supported (the most known is currently 12)\n\n");
    printf ("   -cpr filename  Mode 2: Read the Suyama A residue from a mprime proof file and compare it with\n");
    printf ("                  the A residue calculated by cofact, then run the Suyama cofactor test\n");
    printf ("   -c filename    Same as -cpr above, but -c may be combined with other flags\n");
    printf ("   -u filename    Same as -upr below, but -u may be combined with other flags\n");
    printf ("   -upr filename  Mode 3: Bypass the P%lspin test, read the Suyama A residue from the mprime proof\n", pe);
    printf ("                  file and use it to complete the Suyama cofactor test (mode 3 is much quicker!)\n\n");
    printf ("   -a             Print residues for every squaring (not recommended for large Fermat numbers)\n");
    printf ("   -b             Print full residue in binary (also not recommended for large Fermat numbers)\n");
    printf ("   -d             Print debug information\n");
    printf ("   -h             Print basic help and exit (-hv and -h -sv give increasingly more information)\n");
    printf ("   -i             Special flag for printing certain interim P%lspin residues (e.g. F8, F17, F22)\n", pe);
    printf ("   -k             Use currently known prime factors (as of 2012) for Fermat number being tested.\n");
    printf ("                  Fermat numbers F5 - F19, F21 - F23, and F25 - F30 have known factors stored.\n\n");
    printf ("              **  Do NOT use -k if you believe you have a new Fermat factor to test.   **\n\n");
    printf ("   -m             Special flag for reducing Suyama A and B values modulo the cofactor C\n");
    printf ("   -o             Additionally print Selfridge-Hurwitz residues in octal (default is decimal only)\n");
    printf ("   -v             Print more verbose information\n");
    printf ("   -x             Also print Selfridge-Hurwitz residues in hexadecimal (default is decimal only)\n");
    printf ("   -j             Enable JSON manual results reporting for Mersenne cofactor tests:\n");
    printf ("   -w string      This adds a username to the JSON report.\n");
    printf ("   -q string      This adds the name of which computer ran the test to the JSON report.\n\n");
    printf ("   -p iterations  Print progress every multiple iterations, instead of the default of every 10%%\n");
    printf ("   -sep           Print a separator line at the end of the run to better see multiple runs' output\n");
    printf ("   -z base        Use a different base for the P%lspin or Suyama test (default = base 3)\n", pe);
    printf ("                  If the base is unsuitable for a primality test, modes 1 or 2 revert to a\n");
    printf ("                  Fermat PRobable Prime (PRP) test\n\n");
    printf ("Some examples:\n");
    printf ("    cofact 5 641                  Mode 1 P%lspin test of F5 and Suyama test of cofactor\n", pe);
    printf ("    cofact -k 12                  Mode 1 tests of F12 using its 6 known factors\n");
    printf ("    cofact -kc F17.proof -t 2 17  Mode 2 multithreaded check of a proof of F17 using known factors\n");
    printf ("    cofact -ku F17.proof 17       Mode 3 test skipping the P%lspin test, and running cofactor test\n\n", pe);
    printf ("    cofact -y 11 23               Mode 1 tests of smallest composite Mersenne with a prime exponent\n");
    printf ("    cofact -c p700001.proof 700001 242220807029231            Mode 2 test of a Mersenne number\n");
    printf ("    cofact -u p2033873.proof 2033873 38429209233120600953063  Mode 3 test of a Mersenne number\n");
    printf ("\n");
    }
    if (verbose == 2) {
    printf ("----------------------------------------------------------------------------------------------------\n");
    printf ("\n");
    printf ("  cofact was originally written by Gary B. Gostin to confirm cofactor tests of the Fermat numbers\n");
    printf ("  from F25 up to F30 (the largest of which reaches about 320 million digits in size).\n");
    printf ("  This version has been extensively revised, with various custom modifications by Catherine X. \n");
    printf ("  Cowie for outputting data for her investigation of historical compositeness tests, published at:\n");
    printf ("      https://64ordle.au/fermat/historical/\n\n");
    printf ("  These modifications include:\n\n");
    printf ("  This version also supports Fermat-PRP testing of Mersenne numbers and cofactors.\n\n");
    printf ("  Flag -i to output interim residues for particular Fermat numbers:\n\n");
    printf ("      F17, 20th iteration (cf. Selfridge & Hurwitz, 1964);\n\n");
    printf ("      F22, 13 interim values from 126,000 to 4,182,000 squarings (cf. Trevisan & Carvalho, 1995);\n\n");
    printf ("      Morehead and Western (1905, 1909) used a method for evaluating the residue m+1 squarings \n");
    printf ("      before the final residue. If the -i flag is set for any Fermat number greater than F2, this \n");
    printf ("      interim residue for the (2^m - m - 2)th squaring will be printed.\n");
    printf ("\n");
    printf ("  If the -p flag is also used with -i, then residues will also be printed at each set interval.\n");
    printf ("\n");
    printf ("  Flag -m for reducing the Suyama A and B values by mod C, prior to evaluating \n");
    printf ("      (A - B) mod C (cf. Crandall, Doenias, et al., 1995);\n");
    printf ("\n");
    printf ("  Options -o and -x for printing octal and hex representations of Selfridge-Hurwitz residues;\n");
    printf ("\n");
    printf ("  Flag -b for printing the entire binary representation of the residue;\n");
    printf ("\n");
    printf ("  Undocumented super-verbose flag -sv for outputting full residues of P%lspin tests and from saved \n", pe);
    printf ("  proofs, full values of cofactors, outputting the binary representations of cofactors (yikes), \n");
    printf ("  and other what-not.\n");
    printf ("\n");
    printf ("  Use with care! The super-verbose flag -sv also includes the normal -v level of verbosity, and \n");
    printf ("  switches on -d (debug), -i, -m, -o, and -x flags as well. It is not a good idea to run -sv on \n");
    printf ("  Fermat numbers greater than F10 unless you need or want full listings of cofact's doings.\n");
    printf ("\n");
    printf ("  Any of the following flags may be run together as one argument, i.e. as -abcdhijkmoquvwxz:\n");
    printf ("      -a, -b, -i, -m, -o, -x  for various modifications to the P%lspin or Suyama test output;\n", pe);
    printf ("      -c or -u file           to either check or use a proof file (but you cannot specify both!);\n");
    printf ("      -d, -v,                 for debug or verbose modes;\n");
    printf ("      -h or -hv,              for help or verbose help;\n");
    printf ("      -k,                     to use the known factors for a Fermat number;\n");
    printf ("      -z base,                to use a non-standard base for the P%lspin or Suyama test.\n", pe);
    printf ("  If -c and -u are used together, cofact will report the error and bypass the P%lspin test.\n", pe);
    printf ("  The -c, -u, and -z options cannot be used in a combined flag, e.g. -cuz, as each requires a\n");
    printf ("  filename or variable to be supplied afterward. Not all possible bases are supported for the\n");
    printf ("  P%lspin test.\n", pe);
    printf ("  If -a with either -b and/or -i are used together, cofact will tacitly ignore -b and/or -i.\n");
    printf ("\n");
    printf ("  Conversely, the -cpr, -p, -sep, -sv, -t, and -upr flags must be entered separately.\n");
    printf ("\n");
    printf ("  The following numbers of known factors as of 2012 are programmed with the -k flag:\n");
    printf ("      F12: 6 known factors\n");
    printf ("      F13: 4 known factors\n");
    printf ("      F15, F19, F25: 3 known factors\n");
    printf ("      F16, F17, F18, F27, F30, [F36]: 2 known factors\n");
    printf ("      F14, F21, F22, F23, F26, F28, F29, [F31, F32]: 1 known factor\n");
    printf ("      F5, F6, F7, F8, F9, F10, F11: all factors\n");
    printf ("\n");
    printf ("****  I cannot stress enough - if you are testing for a newly discovered factor,  ****\n");
    printf ("****  do NOT use the -k flag!                                                     ****\n");
    printf ("\n");
    printf ("  Gary Gostin's version of cofact will not allow composite factors to be tested. This version does \n");
    printf ("  allow composite factors, and will show whether any known prime factors divide them. (Frequently \n");
    printf ("  ECM is able to find composite factors, which turn out to be products of known factors.) \n");
    printf ("\n");
    printf ("  If you are running cofactor tests on Mersennes, cofact will have no known factors stored, and \n");
    printf ("  so cannot detect whether a composite factor is comprised of known factors. It will tell you if \n");
    printf ("  a factor is composite, in which case you are strongly encouraged to check the divisibility of \n");
    printf ("  any known factors of that Mersenne.\n");
    printf ("\n");
    printf ("  Other notes:\n");
    printf ("\n");
    printf ("      You cannot test F0. (It doesn't need testing. Try cofact 0 if you don't believe me.)\n");
    printf ("      You cannot test F31 or greater with cofact. (Yet. Preparations are afoot.)\n");
    printf ("      Testing F30 in mode 1 or 2 requires an x86 family processor with AVX-512 extensions.\n");
    printf ("      Using proof files for F21 and above is highly advisable. Proofs for F17 to F29 are available \n");
    printf ("      from:\n");
    printf ("          https://64ordle.au/fermat/ \n");
    printf ("\n");
    printf ("  Results of historical tests cited in my essay:\n");
    printf ("\n");
    printf ("  cofact -a 5 641            1877, demonstration of Th%lsophile P%lspin's theorem with F5;\n", pe, pe);
    printf ("  cofact -ov 7               1905, Morehead and Western separately test F7;\n");
    printf ("  cofact -iov 8              1909, Morehead and Western together test F8;\n");
    printf ("  cofact -v 10               1952, Robinson tests F10 with the SWAC;\n");
    printf ("  cofact -o 13               1960, Paxson tests F13 with an IBM 7090 mainframe;\n");
    printf ("  cofact -o 14               1961, Hurwitz and Selfridge test F14 with a (possibly overclocked?)\n");
    printf ("  cofact -io 17                    IBM 7090, and provide an interim residue for F17;\n");
    printf ("  cofact -o -t 4 20          1988, Buell and Young test F20 with a couple of Cray supercomputers;\n");
    printf ("  cofact -i -t 4 22          1993, Trevisan and Carvalho obtain interim residues of F22 on a Cray,\n");
    printf ("  cofact -mku F21.proof 21         and Crandall, Doenias, et al., run Suyama tests on F19 and F21;\n");
    printf ("  cofact -m 19 70525124609 646730219521      (these two Suyama tests work faster using VDF proofs)\n");
    printf ("  cofact -t 4 24             1999, Crandall, Mayer, and Papadopoulos find F24 composite;\n");
    printf ("  cofact -ku F28.proof 28    2022, Mayer announced results of Suyama tests of F28, F29, and F30.\n");
    printf ("\n");
    printf ("----------------------------------------------------------------------------------------------------\n");
    }
}

int main (int argc, char **argv) {
    int m;                          // M of the Fermat number F_m
    int n_fact;                     // The number of factors entered
    int n_comp;                     // Product of ncomp[i] = 1 if all supplied factors are composite
    int k_fact;                     // The number of previously known factors for the Fermat number
    int kpow[K_FACT];               // How many times a known factor has been exponentiated in the argument string (should never be > 1)
    int ncomp[N_FACT];              // Flag for whether a supplied factor is composite
    unsigned long GWbase;           // Base for manipulations in gwnum, usually but not always equal to GMPbase
    unsigned long exp;              // The Fermat exponent 2^m, or the Mersenne exponent p
    unsigned long x;                // Number of Pepin test square/mod operations
    unsigned long j;                // Iteration counter for square/mod loop
    unsigned long j_progress;       // The next j at which to print progress
    unsigned long j_progress_inc;   // The j increment at which to report progress
    unsigned long k;                // Always 1 for a Fermat number
    unsigned long c;                // Always 1 for a Fermat number, -1 for a Mersenne number
    int threads;                    // Number of threads (cores) to use in gwnum library
    int digits;                     // Number of digits in the cofactor
    int all_int;                    // Flag -a to print all interim residues
    int binary;                     // Flags -b, -o, -x to additionally print Selfridge - Hurwitz residues in binary, octal, hexadecimal
    int check_proof_res;            // Flags -c or -cpr to enable checking the mprime proof file A residue
    int debug;                      // Flag -d to enable printing debug information
                                    // Flag -g reserved
    int help;                       // Flag -h for printing help
    int interim;                    // Flag -i to print select interim residues
    int json;                       // Flag -j to print a JSON
    int known_factors;              // Flag -k to enable using currently known prime factors for a given Fermat number
    int modc;                       // Flag -m to evaluate and print A mod C and B mod C
    int computer;                   // Flag -q to add PrimeNet computer name for JSON string
    int sep;                        // Flag -sep to print a separator line at the end of the run
    int super_verbose;              // Flag -sv for Cathy's print all sorts of super verbose stuff to stdout
    int use_proof_res;              // Flags -u or -upr to enable using the mprime proof file A residue instead of calculating it
    int verbose;                    // Flag to enable printing more information
    int who;                        // Flag -w to add PrimeNet username for JSON string
    int fft_length;                 // report gwnum fft-length for JSON string
    int jacobi;                     // Jacobi (b/F) should equal -1 if we want a definitive result for a Pepin test
    int SH;                         // Print Selfridge - Hurwitz residues if residues are larger than 36 bits
    int prp;                        // Whether a Fermat or Mersenne number is prime
    long fseek_rtn;                 // Return value from fseek
    long ftell_rtn_0, ftell_rtn_1;  // Return value from ftell before and after fseek call
    int res_len;                    // The size of the proof file residue, in bytes
    char cmdline[CMD_LEN];          // The reconstructed command line
    char line[2048];                // Temp string
    unsigned long y;
    int argi, rtn, i, l, z;         // Use n next
    char *symb;                     // A temporary string to display a single symbol or character
    char *flags;                    // Pointer for multiple flags in one argument; z if file location to follow

    wchar_t *pe;                    // We want to have an e with an acute accent. Because reasons
    pe = (wchar_t *) malloc(sizeof(wchar_t) * 2);
    pe[0] = 0x00e9;
    pe[1] = 0;
    setlocale(P_ALL, "");           // However, Unicode handling in C is so dodgy that this is disabled in the default code.

    // Various time variables
    static struct timeval tv_start, tv_stop, tv_progress_start, tv_progress_stop;
    float wall_time, ms_per_iter;
    int wall_hours, wall_mins, wall_secs;

    time_t current_time;
    struct tm *time_block;
    char time_string[TIME_STRING_LEN];

    // gwnum library variables
    gwhandle gwdata;                // Structure for gwlib information
    gwnum r_gw;                     // The square/mode residue
    int gwerr;                      // Error value returned by some gwnum library calls
    double maxerr;                  // The maximum roundoff error returned by gw_get_maxerr

    size_t r_bin_buf_len;           // Number of longs in r_bin buffer
    unsigned long *r_bin;           // Binary array for tranfer of residue from GWNUM to GMP
    int len;                        // Temp

    mpz_t kfac[K_FACT];             // The known factors of the Fermat number
    mpz_t fact[N_FACT];             // The supplied factors of the Fermat number (or Mersenne number)
    mpz_t Fm1;                      // The Fermat number (or Mersenne number) minus one
    mpz_t F;                        // The Fermat number (or Mersenne number)
    mpz_t P;                        // The Pepin residue, later the final Suyama residue, later still the GCD
    mpz_t A;                        // The Suyama A residue
    mpz_t B;                        // The Suyama B residue
    mpz_t Q;                        // The product of known or supplied factors
    mpz_t C;                        // The remaining cofactor
    mpz_t S;                        // The result of the Suyama test (used as a temporary variable en route)
    mpz_t GMPbase;                  // The Fermat-PRP base, usually 3
    mpz_t A_proof;                  // The proof file residue
    mpz_t tmp;                      // Another temporary variable used en route

    char proof_file_name[NAME_LEN]; // Name of the proof file to read and (check or use)
    FILE *fp_proof;                 // Proof file
    int version, hashsize;          // VERSION and HASHSIZE values from the proof file
    char power_s[64];               // POWER string from the proof file
    char proof_desc_s[2048];        // The proof description string: (Fn)/factor_1/factor_2...
    char newline[2];                // Required to avoid the description fscanf from eating part of the residue
    int n_proof;                    // N of the Fermat number in the proof file
    int proof_power, proof_power_mult;  // Proof power and multiplier in the proof file
    long fseek_offset;              // Offset to seek to the proof residue in the proof file
    unsigned char *A_proof_raw;     // Buffer for the proof file raw residue

    // Start the wall time timer
    (void) gettimeofday(&tv_start, (struct timezone *) NULL);

    // Print compile time program information
    printf ("Program to check the primality of a Fermat number and its cofactor: %s,\nVersion %s (%s %s)\n", prog_name, prog_vers, build_date, build_time);

    // Print date and time the program was started
    current_time = time(NULL);
    time_block = localtime(&current_time);
    strftime(time_string, TIME_STRING_LEN, "%A %d %B %Y %X", time_block);
    printf ("Run started: %s\n", time_string);
    printf ("\n");

    // Print the command line
    bzero(cmdline, sizeof(cmdline));
    for (argi=0; argi<argc; argi++) {
        if ((strlen(cmdline) + strlen(argv[argi])) > (CMD_LEN-1)) break;
        strcat (cmdline, argv[argi]);
        strcat (cmdline," ");
    }
    printf ("Command line: %s\n\n", cmdline);

    // Initialize GMP variables
    for (i = 0; i <= N_FACT; i++) mpz_init_set_ui (fact[i], 1L);
    for (i = 0; i <= K_FACT; i++) mpz_init_set_ui (kfac[i], 1L);
    mpz_init_set_ui (GMPbase, 3L);
    mpz_init_set_ui (Fm1, 1L);
    mpz_init_set_ui (F, 1L);
    mpz_init (P);
    mpz_init (A);
    mpz_init_set (B, GMPbase);
    mpz_init (Q);
    mpz_init (C);
    mpz_init (S);
    mpz_init (A_proof);
    mpz_init (tmp);

    mpz_init_set_ui (mask64, 0xffffffffffffffffL);
    mpz_init (r64);

    // Parse command line parameters
    threads = 1;            // Default to 1 thread
    all_int = 0;            // Default to print no interim residues
    binary = 1;             // Default to decimal representation of S-H residues only;
                            // we add 2, 8, and 16 if -b, -o, and -x flags are set
    check_proof_res = 0;    // Default to not checking a proof A residue
    debug = 0;              // Default to no debug
    help = 0;               // Default to bypass help
    interim = 0;            // Default to print no interim residues
    json = 0;               // Default to not printing JSON, or user and computer fields
    known_factors = 0;      // Default to only performing a Pepin test if no Fermat factors have been declared
    modc = 0;               // Default to not evaluate A mod C and B mod C
    j_progress_inc = 0;     // Default of 0 will be changed to 10% of the run
    computer = 0;
    sep = 0;                // Default to no separator line
    super_verbose = 0;      // Default to no super verbose
    use_proof_res = 0;      // Default to calculating the A residue
    verbose = 0;            // Default to no verbose
    who = 0;
    exp = 0;                // Default to no Suyama testing of a Mersenne
    m = 0;                  // Invalid value for Fermat numbers, to make sure m is later set
    z = 0;                  // Flag for combined menu options requiring an additional parameter (-c, -q, -u, -w, -z)
    digits = 0;             // Also an invalid value
    prp = 0;                // Switch to 1 if or when we print a statement of primality
    n_comp = 1;             // Start with an assumption we only have composite supplied factors
    
    // Parse command line arguments starting with "-" args
    // The following loop will exit when first non "-" argument is found that is not allowed for,
    // e.g. -c, -cpr, -u, -upr, -p, -q, -t, -w, -z all expect a following argument (filename or string or variable)
    for (argi = 1; argi < argc; argi++) {
        if ((strcmp(argv[argi], "--help") == 0) || (strcmp(argv[argi], "--HELP") == 0)) {
            usage (0);
            exit (0);
        } else
        if ((strcmp(argv[argi], "-cpr") == 0) || (strcmp(argv[argi], "-CPR") == 0)) {
            check_proof_res = 1;
            argi++;
            strncpy (proof_file_name, argv[argi], NAME_LEN-1);
        } else
        if ((strcmp(argv[argi], "-sv") == 0) || (strcmp(argv[argi], "-SV") == 0)) {       // -sv turns on a lot of flags! Must be a separate flag
            binary = 25;
            debug = 1;
            interim = 1;
            modc = 1;
            sep = 1;
            verbose = 1;
            super_verbose = 1;
        } else
        if ((strcmp(argv[argi], "-p") == 0) || (strcmp(argv[argi], "-P") == 0)) {
            argi++;
            j_progress_inc = atol(argv[argi]);
        } else
        if ((strcmp(argv[argi], "-sep") || (strcmp(argv[argi], "-SEP") == 0)) == 0) {
            sep = 1;
        } else
        if ((strcmp(argv[argi], "-t") == 0) || (strcmp(argv[argi], "-T") == 0)) {
            argi++;
            threads = atoi(argv[argi]);
        } else
        if ((strcmp(argv[argi], "-upr") == 0) || (strcmp(argv[argi], "-UPR") == 0)) {
            use_proof_res = 1;
            argi++;
            strncpy (proof_file_name, argv[argi], NAME_LEN-1);
        } else
        if (strncmp(argv[argi], "-", 1) == 0) {     // Combined -abcdvhijkmoquwxyz flags, processed in that order
            z = 0;
            flags = strpbrk(argv[argi], "aAbBcCdDvVhHiIjJkKmMoOqQuUwWxXyYzZ");      // We are somewhat tolerant of upper case
            if (flags != NULL) {
                flags = strpbrk(argv[argi], "aA");
                if (flags != NULL) all_int = 1;
                flags = strpbrk(argv[argi], "bB");
                if (flags != NULL && (binary & 2) == 0) binary += 2;
                flags = strpbrk(argv[argi], "cC");   // increment z to ensure we advance argument past file
                if (flags != NULL) { check_proof_res = 1; strncpy (proof_file_name, argv[argi+1], NAME_LEN-1); z++; }
                flags = strpbrk(argv[argi], "dD");
                if (flags != NULL) debug = 1;
                flags = strpbrk(argv[argi], "hH");
                if (flags != NULL) help = 1;
                flags = strpbrk(argv[argi], "iI");
                if (flags != NULL) interim = 1;
                flags = strpbrk(argv[argi], "jJ");
                if (flags != NULL) json = 1;
                flags = strpbrk(argv[argi], "kK");
                if (flags != NULL) known_factors = 1;
                flags = strpbrk(argv[argi], "mM");
                if (flags != NULL) modc = 1;
                flags = strpbrk(argv[argi], "oO");
                if (flags != NULL && (binary & 8) == 0) binary += 8;
                flags = strpbrk(argv[argi], "qQ");
                if (flags != NULL) {computer = argi+1; z++;}
                flags = strpbrk(argv[argi], "uU");   // increment z to ensure we advance argument past file
                if (flags != NULL) { use_proof_res = 1; strncpy (proof_file_name, argv[argi+1], NAME_LEN-1); z++; }
                flags = strpbrk(argv[argi], "vV");
                if (flags != NULL) verbose = 1;
                flags = strpbrk(argv[argi], "wW");
                if (flags != NULL) {who = argi+1; z++;}
                flags = strpbrk(argv[argi], "xX");
                if (flags != NULL && (binary & 16) == 0) binary += 16;
                flags = strpbrk(argv[argi], "yY");
                if (flags != NULL) {
                    mpz_set_str (tmp, argv[argi+1], 10);
                    exp = mpz_get_ui (tmp);
                    if (exp < 3) {printf ("Smallest Mersenne exponent must exceed 2.\n\n"); exit (1);}
                    if (mpz_cmp_ui (tmp, exp) != 0 || exp > 1073741824) {printf ("Mersenne exponent must not exceed 2^30 = 1073741824.\n\n"); exit (1);}
                }
                flags = strpbrk(argv[argi], "zZ");   // increment z to ensure we advance argument past number
                if (flags != NULL) { mpz_set_str(B, argv[argi+1], 10); z++; }
                // reserving g for Gerbicz error checking
                flags = strpbrk(argv[argi], "eEfFgGlLnNpPrRsStT1234567890"); // check if there were other letters or numbers in combined flag
                if (flags != NULL) {
                    printf ("Warning: unknown option in command line flag: %s\n", argv[argi]);
                    usage (0);
                    printf ("Ignoring unknown option and processing other flags\n");
                }
                if (z > 1) {
                    printf ("Error: problem with flag: %s %s\nMultiple options in this flag require a parameter; these should be handled separately.\n\n", argv[argi], argv[argi+1]);
                    usage (0);
                    exit (1);
                }
                if (z == 1) argi++;     // increment argument to bypass value (filename or variable) passed in by -c, -q, -u, -w, or -z
            } else {
                printf ("Error: unknown command line flag: %s\n", argv[argi]);
                usage (0);
                exit (1);
            }
        } else {
            break;
        }
    }

    // Print help and exit
    if (help) {
        if (super_verbose) usage (2); else usage (verbose);
        exit (0);
    }

    // Only one of all_int or interim should be active
    if (all_int && interim) interim = 0;

    // Parse m of the Fermat number
    if (argi < argc) {
        if (sscanf (argv[argi], "%d", &m) != 1) {
            if (exp == 0) symb = "Fermat"; else symb = "Mersenne";
            printf ("Error: unable to parse %s number: %s\n", symb, argv[argi]);
            usage (0);
            exit (1);
        }
        argi++;
    } else {
        printf ("Error: must specify a Fermat number between 1 and 30\n");
        usage (0);
        exit (1);
    }

    // If F0 selected, print a message then exit
    if (m == 0) {
        printf ("The P%lspin test cannot be run on Fermat number F0 = 3\nF0 is prime!\n\n", pe);
        goto fast_exit;
    }

    // Make sure the Fermat number is in the range supported by the gwnum or gmp library
    if ((m < 0 || m > 30) && exp == 0) {
        if (m < 0) {
            printf ("Error: cofact only supports Fermat numbers F0 through F30. F%d was specified\n", m);
            exit (1);
        }
        printf ("Advisory: cofact tests Fermat numbers up to F30 only. If your exponent is for a Mersenne number,\nplease add -y immediately before the exponent to suppress this message:\ne.g. ");
        for (i = 0; i < argc; i++) {
            if (i == argi - 1) printf ("-y ");
            printf ("%s ", argv[i]);
        }
        exp = m;
        m = 0;
        printf ("\nRunning Fermat-PRP test on Mersenne M%lu = 2^%lu - 1\n", exp, exp);
    }

    // If F1, F2, F3, or F4 is selected, check whether Pepin test is unable to run and if so, print a message and exit
    if (m > 0 && m < 5) {
        z = 1 << m;
        z = (1 << z) + 1;
        if (mpz_tdiv_ui (B, z) == 0) {
            printf ("The P%lspin test using base ", pe);
            mpz_out_str (stdout, 10, B);
            printf (" cannot be run on Fermat number F%d = %d\nF%d is prime!\n\n", m, z, m);
            goto fast_exit;
        }
    }
    if (exp != 0) {     // If exp is not zero then m is a Mersenne exponent; we make m equal to zero to avoid confusion
        m = 0;
        known_factors = 0;
        if (exp != 3) {
            mpz_set_ui (C, exp);
            mpz_sub_ui (tmp, C, 1L);
            mpz_powm (P, GMPbase, tmp, C);
            if (mpz_cmp_ui (P, 1L) != 0) {printf ("Note the Mersenne exponent %lu is composite.\n\n", exp); json = 0;}
        }
    }
    k_fact = 0;
    if (exp > 36) SH = 6; else SH = m;

    if (m > 0) { // Setup for Fermat numbers
        if (debug) printf ("Calculate the Fermat number F%d = 2^(2^%d)+1 and F-1\n", m, m); fflush (stdout);
        exp = 1 << m;                   // Exponent of 2 = 2^m
        mpz_mul_2exp (Fm1, Fm1, exp);   // Fm1 = 2^2^m
        mpz_add_ui (F, Fm1, 1L);        // F = Fm1 + 1
        // Safe method for calculating Fermat numbers beyond F30 (unneeded for now)
        // if (m < 31) exp = 1 << m; else exp = 1 << 30;   // Exponent of 2 = 2^m
        // mpz_mul_2exp (Fm1, Fm1, exp);                   // Fm1 = 2^2^m
        // for (i = 30; i < m; i++) {
        //     mpz_mul (Fm1, Fm1, Fm1);
        //     if (debug) printf ("Calculating F%d - 1\n", i+1); fflush (stdout);
        // }
        // mpz_add_ui (F, Fm1, 1L);                        // F = Fm1 + 1

        if (debug) printf ("Set up known factors kfac[i] for the Fermat number specified,\nwith trivial factors for Fermat primes F1-F4, unfactored F20 and F24\n"); fflush (stdout);
        if (m > 4 && m < 33 && m != 20 && m != 24) {
            switch (m) {
                case 5:
                    k_fact = 2;
                    mpz_set_str (kfac[0], "641", 10); mpz_set_str (kfac[1], "6700417", 10);
                    break;
                case 6:
                    k_fact = 2;
                    mpz_set_str (kfac[0], "274177", 10); mpz_set_str (kfac[1], "67280421310721", 10);
                    break;
                case 7:
                    k_fact = 2;
                    mpz_set_str (kfac[0], "59649589127497217", 10); mpz_set_str (kfac[1], "5704689200685129054721", 10);
                    break;
                case 8:
                    k_fact = 2;
                    mpz_set_str (kfac[0], "1238926361552897", 10); mpz_set_str (kfac[1], "93461639715357977769163558199606896584051237541638188580280321", 10);
                    break;
                case 9:
                    k_fact = 3;
                    mpz_set_str (kfac[0], "2424833", 10); mpz_set_str (kfac[1], "7455602825647884208337395736200454918783366342657", 10); mpz_set_str (kfac[2], "741640062627530801524787141901937474059940781097519023905821316144415759504705008092818711693940737", 10);
                    break;
                case 10:
                    k_fact = 4;
                    mpz_set_str (kfac[0], "45592577", 10); mpz_set_str (kfac[1], "6487031809", 10); mpz_set_str (kfac[2], "4659775785220018543264560743076778192897", 10); mpz_set_str(kfac[3],"130439874405488189727484768796509903946608530841611892186895295776832416251471863574140227977573104895898783928842923844831149032913798729088601617946094119449010595906710130531906171018354491609619193912488538116080712299672322806217820753127014424577", 10);
                    break;
                case 11:
                    k_fact = 5;
                    mpz_set_str (kfac[0], "319489", 10); mpz_set_str (kfac[1], "974849", 10); mpz_set_str (kfac[2], "167988556341760475137", 10); mpz_set_str (kfac[3], "3560841906445833920513", 10); mpz_set_str(kfac[4],"173462447179147555430258970864309778377421844723664084649347019061363579192879108857591038330408837177983810868451546421940712978306134189864280826014542758708589243873685563973118948869399158545506611147420216132557017260564139394366945793220968665108959685482705388072645828554151936401912464931182546092879815733057795573358504982279280090942872567591518912118622751714319229788100979251036035496917279912663527358783236647193154777091427745377038294584918917590325110939381322486044298573971650711059244462177542540706913047034664643603491382441723306598834177", 10);
                    break;
                case 12:
                    k_fact = 6;
                    mpz_set_str(kfac[0],"114689", 10); mpz_set_str(kfac[1],"26017793", 10); mpz_set_str(kfac[2],"63766529", 10); mpz_set_str(kfac[3],"190274191361", 10); mpz_set_str(kfac[4],"1256132134125569", 10); mpz_set_str(kfac[5],"568630647535356955169033410940867804839360742060818433", 10);
                    break;
                case 13:
                    k_fact = 4;
                    mpz_set_str(kfac[0],"2710954639361", 10); mpz_set_str(kfac[1],"2663848877152141313", 10); mpz_set_str(kfac[2],"3603109844542291969", 10); mpz_set_str(kfac[3],"319546020820551643220672513", 10);
                    break;
                case 14:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"116928085873074369829035993834596371340386703423373313", 10);
                    break;
                case 15:
                    k_fact = 3;
                    mpz_set_str(kfac[0],"1214251009", 10); mpz_set_str(kfac[1],"2327042503868417", 10); mpz_set_str(kfac[2],"168768817029516972383024127016961", 10);
                    break;
                case 16:
                    k_fact = 2;
                    mpz_set_str(kfac[0],"825753601", 10); mpz_set_str(kfac[1],"188981757975021318420037633", 10);
                    break;
                case 17:
                    k_fact = 2;
                    mpz_set_str(kfac[0],"31065037602817", 10); mpz_set_str(kfac[1],"7751061099802522589358967058392886922693580423169", 10);
                    break;
                case 18:
                    k_fact = 2;
                    mpz_set_str(kfac[0],"13631489", 10); mpz_set_str(kfac[1],"81274690703860512587777", 10);
                    break;
                case 19:
                    k_fact = 3;
                    mpz_set_str(kfac[0],"70525124609", 10); mpz_set_str(kfac[1],"646730219521", 10); mpz_set_str(kfac[2],"37590055514133754286524446080499713", 10);
                    break;
                case 21:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"4485296422913", 10);
                    break;
                case 22:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"64658705994591851009055774868504577", 10);
                    break;
                case 23:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"167772161", 10);
                    break;
                case 25:
                    k_fact = 3;
                    mpz_set_str(kfac[0],"25991531462657", 10); mpz_set_str(kfac[1],"204393464266227713", 10); mpz_set_str(kfac[2],"2170072644496392193", 10);
                    break;
                case 26:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"76861124116481", 10);
                    break;
                case 27:
                    k_fact = 2;
                    mpz_set_str(kfac[0],"151413703311361", 10); mpz_set_str(kfac[1],"231292694251438081", 10);
                    break;
                case 28:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"1766730974551267606529", 10);
                    break;
                case 29:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"2405286912458753", 10);
                    break;
                case 30:
                    k_fact = 2;
                    mpz_set_str(kfac[0],"640126220763137", 10); mpz_set_str(kfac[1],"1095981164658689", 10);
                    break;
/*   Future planning: later versions of gwnum may support F31 and F32. And Mlucas might eventually support F36. If not, we can at least hope! CXC
                case 31:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"46931635677864055013377", 10);
                    break;
                case 32:
                    k_fact = 1;
                    mpz_set_str(kfac[0],"25409026523137", 10);
                    break;
                case 36:
                    k_fact = 2;
                    mpz_set_str(kfac[0],"2748779069441", 10); mpz_set_str(kfac[1],"1033434552359452673", 10);
                    break;
*/
            }
        }
    } else {        // Set up F for Mersenne exponents
        if (debug) printf ("Calculate the Mersenne number M%lu = 2^%lu-1 and M%lu - 1\n", exp, exp, exp); fflush (stdout);
        mpz_mul_2exp (F, F, exp);       // F   = 2^exp
        mpz_sub_ui (F, F, 1L);          // F   = 2^exp - 1
        mpz_sub_ui (Fm1, F, 1L);        // Fm1 = 2^exp - 2
    }

    n_fact = 0;                 // Initialise the expected number of factors to test after Pepin test
    for (i = 0; i < k_fact; i++) {kpow[i] = 0;}
    if (known_factors && mpz_cmp_ui (kfac[0], 1L) != 0) {
        n_fact = k_fact;
        for (i = 0; i < k_fact; i++) {
            mpz_set (fact[i], kfac[i]);
            kpow[i] = 1;
            ncomp[i] = 0;
        }
    }
    // Parse the user-submitted factors, and do some various sanity tests
    n_fact += argc - argi;
    if (n_fact > N_FACT) {
        printf ("Error: too many factors (%d) supplied. Maximum number of factors is %d.\n", n_fact, N_FACT);
        if (known_factors) printf ("Try re-running cofact without the -k flag.\n");
        exit (1);
    }
    z = 0;
    if (debug) printf("k_fact = %d, n_fact = %d, argi = %d\n", k_fact, n_fact, argi);
    for (i = k_fact*known_factors; i < n_fact; i++) {
        if (mpz_set_str(fact[i-z], argv[argi], 10) != 0) {
            printf ("Error: cannot parse factor: %s (continuing without it)\n", argv[argi]);
            z++;
        } else {
            if (mpz_cmp_ui (fact[i-z], 1L) <= 0 || mpz_cmp (fact[i-z], F) == 0) {
                printf ("Error: trivial factor %s omitted (continuing without it)\n", argv[argi]);
                z++;
            } else {
                mpz_tdiv_r (tmp, F, fact[i-z]);       // tmp = F mod fact[i]
                if (mpz_cmp_ui (tmp, 0L) != 0) {
                    printf ("Error: supplied factor %s does not divide ", argv[argi]);
                    if (m == 0) printf ("M%lu", exp); else printf ("F%d", m);
                    printf (": (continuing without it)\n");
                    z++;
                }
            }
        }
        argi++;
    }
    n_fact -= z;
    for (i = 0; i < n_fact; i++) {
        if (!known_factors || (known_factors && i >= k_fact)) {
            // Check that the supplied factor is not a duplicate
            for (j = 0; j < i; j++) {
                if (m != 0 && mpz_cmp (fact[i], fact[j]) == 0) {
                    printf ("Error: supplied factor is a duplicate: ");
                    mpz_out_str (stdout, 10, fact[i]);
                    printf ("\nKnown prime factors cannot be exponentiated and still divide the Fermat number.\n");
                    if (known_factors) printf ("Try re-running cofact without the -k flag.\n");
                    exit (1);
                }
            }
            // Check that the known factor is a pseudo-prime using Fermat's little theorem
            mpz_sub_ui (tmp, fact[i], 1L);
            if (m == 0 && mpz_tdiv_ui (fact[i], 3L) == 0) {
                if (mpz_cmp_ui (fact[i], 3L) != 0) {
                    printf ("Supplied factor ");
                    mpz_out_str (stdout, 10, fact[i]);
                    printf (" is composite.\n");
                    ncomp[i] = 1;
                } else {
                    ncomp[i] = 0;
                }
            } else {
                mpz_powm (P, GMPbase, tmp, fact[i]);
                if (mpz_cmp_ui (P, 1L) != 0) {
                    printf ("Supplied factor ");
                    mpz_out_str (stdout, 10, fact[i]);
                    symb = " = ";
                    mpz_set (P, fact[i]);
                    for (j = 0; j < k_fact; j++) {
                        mpz_tdiv_r (tmp, fact[i], kfac[j]);
                        if (mpz_cmp_ui (tmp, 0L) == 0) {
                            printf ("%s", symb);
                            symb = " * ";
                            mpz_out_str (stdout, 10, kfac[j]);
//                             printf (" ");
                            kpow[j]++;
                            mpz_tdiv_q (P, P, kfac[j]);
                        }
                    }
                    if (mpz_cmp_ui (P, 1) != 0) {
                        if (k_fact > 0) {
                            printf (" * ");
                            mpz_out_str (stdout, 10, P);
//                             printf (" ");
                        }
                        printf (" is composite.\n\n");
                        if (m != 0) {
                            mpz_out_str (stdout, 10, P);
                            printf (" is NOT a known factor!\n\n");
                        }
                    } else {
                        printf (" is composite.\n");
                    }
                    ncomp[i] = 1;
                } else {
                    ncomp[i] = 0;
                    n_comp = 0;
                }
            }
        }
    }
    for (i = 0; i < k_fact; i++) {
        if (m != 0 && kpow[i] > 1) {
            printf ("Prime factor ");
            mpz_out_str (stdout, 10, kfac[i]);
            printf (" appears more than once in the command string, as the factor of a composite factor.\n");
            printf ("Please make sure known prime factors only appear once.\n");
            if (known_factors) printf ("Try re-running cofact without the -k flag, as this includes all %d known prime factors.\n", k_fact);
            exit (1);
        }
    }
    // Calculate Q = product of the known or supplied factors and check that combined, they divide F
    mpz_set (Q, fact[0]);
    for (i = 1; i < n_fact; i++) {
        mpz_mul (Q, Q, fact[i]);
    }
    // Test whether cofactor F = 0 mod Q
    mpz_div (C, F, Q);
    mpz_tdiv_r (tmp, F, Q);
    if (mpz_cmp_ui (tmp, 0L) != 0 && n_fact > 0) {
        printf ("Error: each supplied factor taken individually divides ");
        if (m == 0) printf ("M%lu,\nbut M%lu", exp, exp); else printf ("F%d,\nbut F%d", m, m);
        printf (" is not equal to 0 modulo the combined product of factors.\n\nPlease resolve which factors you wish to test.\n");
        exit (1);
    }

    z = 0;

    // If checking or using a proof file residue is enabled, read the proof file
    if (check_proof_res && use_proof_res) {
        printf ("Error: Can only specify one of -cpr and -upr\n\n");
        printf ("Aborting P%lspin test and using specified proof for Suyama test\n", pe);
        check_proof_res = 0;
    }

    if (check_proof_res || use_proof_res) {
        printf ("Reading residue from proof file: %s\n", proof_file_name);

        if ((fp_proof = fopen (proof_file_name, "rb")) == NULL) {               // The "b" is not needed according to fopen man page
            printf ("Error: Cannot open proof file: %s\n", proof_file_name);
            exit (1);
        }

        if (fscanf (fp_proof, "PRP PROOF\n") != 0) {
            printf ("Error: Cannot read PRP PROOF from proof file header\n");
            exit (1);
        }
        if (fscanf (fp_proof, "VERSION=%d\n", &version) != 1 || (version != 1 && version != 2)) {
            printf ("Error: Cannot read VERSION number from proof file header\n");
            exit (1);
        }
        if (fscanf (fp_proof, "HASHSIZE=%d\n", &hashsize) != 1 || hashsize < 32 || hashsize > 64) {
            printf ("Error: Cannot read HASHSIZE value from proof file header\n");
            exit (1);
        }
        if (fscanf (fp_proof, "POWER=%s\n", &power_s) != 1) {
            printf ("Error: Cannot read POWER string from proof file header\n");
            exit (1);
        }
        if (fscanf (fp_proof, "BASE=%ld\n", &y) == 1) {
            if (mpz_cmp_ui (B, y) != 0) printf ("Error: Proof base %ld does not equal cofact argument -z\n", y);
        } else {
            if (y == 0) y = 3;
        }
        if (fscanf (fp_proof, "NUMBER=%2047[^\n]%1[\n]", proof_desc_s, newline) != 2) {
            printf ("Error: Cannot read proof description string from proof file header\n");
            exit (1);
        }

        printf ("Proof file description: %s\n", proof_desc_s);

        if (m != 0) {   // Parse the Fermat number exponent from the proof file. Could be F# or (F#).
            if (sscanf (proof_desc_s, "F%d", &n_proof) != 1) {
                if (sscanf (proof_desc_s, "(F%d)", &n_proof) != 1) {
                    printf ("Error: Cannot parse proof description string from proof file header\n");
                    exit (1);
                }
            }
        } else {   // Parse the Mersenne number exponent from the proof file. Could be M# or (M#).
            if (sscanf (proof_desc_s, "M%d", &n_proof) != 1) {
                if (sscanf (proof_desc_s, "(M%d)", &n_proof) != 1) {
                    printf ("Error: Cannot parse proof description string from proof file header\n");
                    exit (1);
                }
            }
        }

        // Allocate a buffer of 2^n / 8 bytes to store the raw A residue
        if (m != 0) res_len = 1 << (n_proof - 3);   // e.g. for F25, allocate 2^22 bytes
            else res_len = (n_proof + 7) >> 3;      //   or for M3355467, same
        if ((A_proof_raw = calloc (res_len+1, sizeof (unsigned char))) == NULL) {
            printf ("Error: Unable to allocate buffer for proof file residue\n");
            exit (1);
        }

        // Parse the Proof Power from the proof file. Supported formats are "#" and "#x2".
        // If proof power is "#x2" then seek to the position in the file of the second proof.
        // If proof power is "#" then no seek is required.
        if (debug) printf ("Proof file power: %s\n", power_s);
        if (sscanf (power_s, "%dx%d", &proof_power, &proof_power_mult) == 2) {
            if (proof_power >= 5 && proof_power <= 9 && proof_power_mult == 2) {
                fseek_offset = (proof_power + 1) * res_len;

                if (debug) printf ("Calling fseek (fp_proof, offset = %lx, SEEK_CUR)\n", fseek_offset);
                ftell_rtn_0 = ftell (fp_proof);
                fseek_rtn   = fseek (fp_proof, fseek_offset, SEEK_CUR);
                ftell_rtn_1 = ftell (fp_proof);
                if (fseek_rtn != 0 || (ftell_rtn_1 - ftell_rtn_0) != fseek_offset) {
                    printf ("Error: seek to second proof in proof file failed\n");
                    printf ("    fseek_offset = %ld, fseek_rtn = %ld, ftell_rtn_0 = %ld, ftell_rtn_1 = %ld\n", fseek_offset, fseek_rtn, ftell_rtn_0, ftell_rtn_1);
                    exit (1);
                }
            } else {
                printf ("Error: proof power or proof power multiplier not supported. POWER string = \"%s\", power = %d, mult = %d\n", power_s, proof_power, proof_power_mult);
                exit (1);
            }
        }
        if (debug && y != 3) printf ("Proof base: %ld\n", y);

        // Read the A residue from the proof file
        if ((rtn = fread (A_proof_raw, 1, res_len, fp_proof)) != res_len) {
            printf ("Error: Cannot read residue from proof file. Returned %d\n", rtn);
            exit (1);
        }
/*
        printf ("Proof file residue: \n");
        for (i=0; i<16; i++) {
            printf ("%02x ", A_proof_raw[i]);
        }
        printf ("\n");
*/
        if (debug) {
            printf ("Proof file A residue LSBs: \n");
            for (i=0; i<16; i++) {
                printf ("%02x ", A_proof_raw[i]);
            }
            printf ("\n");
        }
        mpz_import (A_proof, res_len, -1, sizeof (unsigned char), 0, 0, A_proof_raw);
        if (super_verbose) {
            printf ("\n");
            print_mpz (A_proof, 16, "A_proof");
        }
        free (A_proof_raw);
        printf ("\n");
    }

    // If "use proof residue" enabled, skip the A calculation steps; otherwise perform them
    if (use_proof_res) {
        printf ("Using A residue from proof file instead of calculating it\n");
        if (m != 0) printf ("Skipping the P%lspin test\n\n", pe);
        if (mpz_cmp_ui (B, 3L) < 0) { printf ("Fermat-PRP base is unuseable\n\nSetting PRP base to %lu\n\n", y); mpz_set_ui (B, y);}
        x = mpz_get_ui (B);
        if (mpz_cmp_ui (B, x) == 0) {
            while ((x & 1) == 0) {x = x >> 1;}
            if (x == 1) { printf ("The Fermat-PRP base cannot be a power of 2.\n\nSetting PRP base to %lu\n\n", y); mpz_set_ui (B, y);}
        }
        mpz_set (A, A_proof);
        mpz_set (GMPbase, B);
        mpz_set (B, A_proof);
        if (exp > 36 && debug) {
                if (m == 0) symb = "Final residue before modular division:  "; else symb = "                                        ";
                printf ("%s|      Selfridge - Hurwitz residues\n                       mod 2^64 (hex)   |   mod 2^36    mod 2^36-1   mod 2^35-1\n", symb);
        }
    } else {
        // If not using proof file residue, do the full Pepin and Suyama calculations; first, sanity checks for useable Pepin base

        if (mpz_cmp_ui (B, 3L) < 0) { printf ("Please select a useable base for the P%lspin test, e.g. -z 3, -z 5, -z 6, -z 7, ...\n(The OEIS has lists of such bases: https://oeis.org/A129802 or https://oeis.org/A102742)\n\nSetting PRP base to 3\n\n", pe); mpz_set_ui (B, 3L);}
        if (m != 0) jacobi = mpz_jacobi (B, F); // if jacobi = -1 then we can do a Pepin test
        if (debug && m != 0) {printf ("Jacobi ("); mpz_out_str (stdout, 10, B); printf ("/F%d) = %d\n", m, jacobi);}
        y = mpz_get_ui (B);
        l = 0;
        if (mpz_cmp_ui (B, y) == 0) {
            x = 65536;
            for (i = 0; i < 48; i++) {
                if (x - y == 1 || y - x == 1) l = 2; // l = 2 means we have likely dodgy Fermat-PRP
                x = x << 1;
            }
            x = y;
            while ((x & 1) == 0) {x = x >> 1;}
            if (x == 1) { printf ("The P%lspin base cannot be a power of 2.\n\nSetting PRP base to 3\n\n", pe); mpz_set_ui (B, 3L); jacobi = -1;}
        }
        if (l == 2) printf ("*** Warning: using base %lu may give incorrect results for a Fermat-PRP test.\n\n", y);
            else if (jacobi != -1 && m != 0) printf ("Please use a standard base for the P%lspin test such as 3, 5, 6, 7, ...\n(The OEIS has lists of such bases: https://oeis.org/A129802 or https://oeis.org/A102742)\n\nRunning Fermat-PRP test instead\n\n", pe);
        mpz_set (GMPbase, B);
        if (jacobi == -1) {
            if (mpz_cmp_ui (GMPbase, 3L) == 0) symb = ""; else symb = ", base ";
            printf ("Testing F%d for primality using the P%lspin test%s", m, pe, symb);
            if (mpz_cmp_ui (GMPbase, 3L) != 0) mpz_out_str (stdout, 10, GMPbase);
            printf ("\n");
        }
        printf ("Using %d threads in gwnum library\n", threads);
        fflush (stdout);

        k = 1;                          // k for modulo value
        if (m == 0) c = -1; else c = 1; // c for Mersennes or Fermats

        if (debug) printf ("Calling gwinit (gwhandle = %p)\n", &gwdata); 
        gwinit (&gwdata);                                       // Initialize the gwnum handle

        if (debug) printf ("Calling gwset_num_threads (gwhandle = %p, num_threads = %ld)\n", &gwdata, (unsigned long) threads); 
        gwset_num_threads (&gwdata, (unsigned long) threads);   // Set number of threads to use

        if (debug) printf ("Calling gwset_safety_margin (gwhandle = %p, safety_margin = %lf)\n", &gwdata, (double) 2.0); 
        gwset_safety_margin (&gwdata, (double) 2.0);            // Had to set this to 3 in pmfs to prevent calc errors with very large N

        if (debug) printf ("Calling gwsetup (gwhandle = %p, k = %lf, b = %ld, n = %ld, c = %ld)\n", &gwdata, (double) k, 2L, exp, c); 
        gwerr = gwsetup (&gwdata, (double) k, 2L, exp, c);      // Setup to use modulo F = 2^2^m + 1 or M = 2^exp - 1
                                                                // Note that K is double, so only values <= 53 bits can be represented. GWNUM checks for this.
        if (gwerr) {
            if (gwerr == 1002) {
                printf ("gwsetup error = 1002 (Number too large for the FFTs)\n");
                if (m == 30) printf ("Note that gwnum requires an AVX512 computer to support F30\n");
            } else {
                printf ("gwsetup error = %d\n", gwerr);
            }
            exit (1);
        }

        gwsetnormroutine (&gwdata, 0, 1, 0);                    // Set flag to enable round-off error checking
                                                                // This call must be AFTER gwsetup
        if (verbose) {
            gwfft_description (&gwdata, line);
            printf ("fft_description: %s\n", line);
            printf ("fftlen = %ld\n", gwfftlen (&gwdata));
            printf ("near_fft_limit = %d\n", gwnear_fft_limit (&gwdata, (double)3.0));
            printf ("\n");
        }

        r_gw = gwalloc (&gwdata);                               // Allocate a GW number for the residue
        if (r_gw == NULL) {
            printf ("gwalloc for r_gw failed\n");
            exit (1);
        }

        // Initialize r_gw = base for Pepin test = 3
        GWbase = mpz_get_ui (GMPbase);
        binary64togw (&gwdata, &GWbase, 1L, r_gw);
        fft_length = gwfftlen (&gwdata);
        gw_clear_maxerr (&gwdata);

        // Create buffer for transfer of residues from GWNUM to GMP
        r_bin_buf_len = exp / 64 + 1;
        r_bin = (unsigned long *) calloc (r_bin_buf_len, sizeof (unsigned long));
    /*
        len = gwtobinary64 (&gwdata, r_gw, r_bin, r_bin_buf_len);
        printf ("base = %2ld, r_gw = %016lx %016lx\n", GWbase, r_bin[1], r_bin[0]);
    */

        x = exp - 1;                                            // Number of Pepin test square/mod steps: x = 2^n - 1

        // If the progress print increment has not been set and the test is likely to take more than a second (at least 100000 steps), set it by default to 10% of the run
        if (j_progress_inc == 0 && x > 100000) j_progress_inc = x / 10;                // Default to 10% of the run

        j_progress = j_progress_inc;
        (void) gettimeofday(&tv_progress_start, (struct timezone *) 0);

        // Flags a and b cannot be run together with m > 5
        if (all_int && m > 5 && (binary & 2) == 2) binary += -2;
        if (m == 0) y = 6; else y = m;
        if (interim || all_int || j_progress_inc < x) {
            if (jacobi == -1) printf ("Calculating %ld", x); else printf ("Calculating %ld", x+1);
            printf (" modular squaring iterations from base ");
            mpz_out_str (stdout, 10, GMPbase);
            printf (":\n");
            if (exp > 36 && (interim || all_int)) printf ("Interim residues:                       |      Selfridge - Hurwitz residues\nIteration              mod 2^64 (hex)   |   mod 2^36    mod 2^36-1   mod 2^35-1\n");
        }

        // Almost all the runtime is in the following loop
        for (j = 1; j <= x; j++) {
            if (j < 24) {                                               // FIXME Good for n <= 2^24? Could this be set more intelligently?
                gwsquare2_carefully (&gwdata, r_gw, r_gw);              // r_gw = (r_gw ^ 2) mod F
            } else {
//              gwsquare2 (&gwdata, r_gw, r_gw);                        // r_gw = (r_gw ^ 2) mod F      Use this line when using gwnum from mprime v29.8
                gwsquare2 (&gwdata, r_gw, r_gw, 0);                     // r_gw = (r_gw ^ 2) mod F      Use this line when using gwnum from mprime v30.8
                                                                        // NOTE, gwnum 30.8 has extra options requiring additional variable set to 0; see gwnum.h (CX Cowie)
            }
            maxerr = gw_get_maxerr (&gwdata);
            if (maxerr >= 0.45) {
                printf ("Roundoff warning: k = %ld, m = %d, iteration = %ld, maxerr = %22.20lf\n", k, m, j, maxerr);
                gw_clear_maxerr (&gwdata);
            }
            k = 0;                              // Use k to obtain a residue under certain conditions
            if (all_int || j == x) k = 1;
            else if (j_progress_inc > 0 && j >= j_progress && interim) k = 1;
            else if (interim && (((j == x - m - 1) && m > 2) || (m == 17 && j == 20) || (m == 22 && (j == 126000 || j == 354000 || j == 486000 || j == 790000 || j == 1078000 || j == 1430000 || j == 1854000 || j == 2390000 || j == 2718000 || j == 3046000 || j == 3542000 || j == 3838000 || j == 4182000)))) k = 1;
            // Convert Pepin residue r_gw to r_bin to P
            if (k == 1) {
                len = gwtobinary64 (&gwdata, r_gw, r_bin, r_bin_buf_len);
                mpz_import (P, len, -1, 8, 0, 0, r_bin);
            }
            if (j_progress_inc > 0 && j >= j_progress) {
                (void) gettimeofday(&tv_progress_stop, (struct timezone *) 0);
                wall_time = tv_secs(tv_progress_stop) - tv_secs(tv_start);
                wall_hours = wall_time / 3600;
                wall_mins = (wall_time - (wall_hours * 3600)) / 60;
                wall_secs = (wall_time - (wall_hours * 3600) - (wall_mins * 60));
                ms_per_iter = (tv_msecs(tv_progress_stop) - tv_msecs(tv_progress_start)) / j_progress_inc;
                if (ms_per_iter > 10000) {ms_per_iter = ms_per_iter / 1000; symb = " ";} else symb = "m";
                printf ("%10ld (%5.1f%%), %ss/iter: %9.3lf |                 Wall time = %4d:%02d:%02d (HH:MM:SS)\n", j, 100.0 * j / x, symb, ms_per_iter, wall_hours, wall_mins, wall_secs);
                if (interim) {
                    printf ("           ");
                    print_residues (P, binary, SH, "Interim");
                }
                fflush (stdout);
                j_progress += j_progress_inc;
                tv_progress_start.tv_sec  = tv_progress_stop.tv_sec;
                tv_progress_start.tv_usec = tv_progress_stop.tv_usec;
            }
            if (all_int && j < x) {
                printf ("%10ld ", j);
                print_residues (P, binary, SH, "Interim");
                if (x == j + 1) {
                    printf ("\n");
                }
                fflush (stdout);
            }
            if (interim || all_int) {
                if (((j == x - m - 1) && m > 2) || (m == 17 && j == 20) || (m == 22 && (j == 126000 || j == 354000 || j == 486000 || j == 790000 || j == 1078000 || j == 1430000 || j == 1854000 || j == 2390000 || j == 2718000 || j == 3046000 || j == 3542000 || j == 3838000 || j == 4182000))) {
                    printf ("%10ld ", j);
                    print_residues (P, binary, SH, "Interim");
                    if (super_verbose || (verbose && m > 0 && m < 12)) {
                        printf ("\n");
                        mpz_out_str (stdout, 10, GMPbase);
                        printf ("^2^%lu == ", j);
                        mpz_out_str (stdout, 10, P);
                        printf (" modulo F%d\n\n",m);
                    }
                    fflush (stdout);
                }
            }
        }

        // Check for errors
        gwerr =  gw_test_for_error (&gwdata);
        if (gwerr) {
            printf ("Error: gw_test_for_error = %d\n", gwerr);
            exit (1);
        }

        if (m > 0 && verbose) {
            if (len < 5) { // print full residues if they are 4 or less words in size
                printf ("P%lspin P%d residue: ", pe, m);
                for (i = len; i > 0; i--) {
                    printf ("%016lx\n", r_bin[i-1]);
                }
                printf ("\n");
            } else  printf ("P%lspin P%d residue: length = %d words, %016lx %016lx ... %016lx %016lx\n", pe, m, len, r_bin[len-1], r_bin[len-2], r_bin[1], r_bin[0]);
        }
        if (jacobi == -1 || debug || interim || all_int) { // if jacobi is not -1, we do *not* have a valid Pepin test base (but we may still be able to do a Suyama test)
            if (exp > 36 && !interim && !all_int) {
                printf ("                                        |      Selfridge - Hurwitz residues\n                       mod 2^64 (hex)   |   mod 2^36    mod 2^36-1   mod 2^35-1\n");
                y = m;
            }
            if (m == 0 || jacobi != -1) print_residues (P, binary, SH, "Penultimate"); else print_residues (P, binary, m, "Pepin");
            if (super_verbose || (verbose && m > 0 && m < 12)) {
                printf ("\nP%d == ", m);
                mpz_out_str (stdout, 10, P);
                printf (" modulo F%d\n", m);
            }
            fflush (stdout);
        }

        if (mpz_cmp (P, Fm1) == 0 || mpz_cmp_ui (P, 1L) == 0) z = 1;
        if (z == 1 && m > 0) {
            if (jacobi == -1) symb = ""; else if (k == 2 && k_fact > 0) symb = " (probably not***)"; else symb = " (probably)";
            printf ("\nF%d is%s prime!\n", m, symb);
            z = 1; prp = 1; // prp keeps track of whether we have printed a statement of primality or prp
        } else if (m != 0) {
            if (jacobi == -1 && k_fact > 0) {
                printf ("\nGerbicz check of P%lspin residue:", pe);     // Gerbicz sanity check, if there are known factors
                for (i = 0; i < k_fact; i++) {          // note, P = b^2^(2^m - 1) mod F_m = b^(1/2(F_m - 1)) mod F_m
                    mpz_tdiv_r (A, P, kfac[i]);         // A = P (mod p), where p is a prime factor of F_m
                    mpz_set_ui (S, 1L);
                    mpz_mul_2exp (B, S, x);             // B = 2^(2^m - 1)
                    mpz_sub (tmp, kfac[i], S);          // tmp = p - 1
                    mpz_tdiv_r (S, B, tmp);             // S = 2^(2^m - 1) (mod p - 1)
                    mpz_powm (B, GMPbase, S, kfac[i]);     // B = b^S (mod p)
                    if (mpz_cmp (A, B) == 0) {
                        printf ("\nP%d == ", m);
                        mpz_out_str (stdout, 10, GMPbase);
                        printf ("^(2^%lu mod ", x);
                        mpz_out_str (stdout, 10, tmp);
                        printf (") == ");
                        mpz_out_str (stdout, 10, B);
                        printf (" mod ");
                        mpz_out_str (stdout, 10, kfac[i]);
                    } else {printf ("\nP%lspin residue has been calculated incorrectly!\n\n", pe); exit (1);}
                }
                printf ("\nP%lspin residue passes check.\n", pe);
            }
            if (jacobi == -1) {
                printf ("\nF%d is composite.\n\n", m);
                z = 0;
            }
        }

        // Square/mod one more time to get A. This is the mprime proof file residue.
//      gwsquare2 (&gwdata, r_gw, r_gw);        // r_gw = (r_gw ^ 2) mod F      Use this line when using gwnum from mprime v29.8
        gwsquare2 (&gwdata, r_gw, r_gw, 0);     // r_gw = (r_gw ^ 2) mod F      Use this line when using gwnum from mprime v30.8 or later
                                                // NOTE, gwnum 30.8's gwsquare2 has extra options requiring additional variable set to 0; see gwnum.h (CX Cowie)
        len = gwtobinary64 (&gwdata, r_gw, r_bin, r_bin_buf_len);
        mpz_import (A, len, -1, 8, 0, 0, r_bin);

        if (check_proof_res) {
            if (mpz_cmp (A, A_proof) == 0) {
                printf ("Calculated A residue matches proof file residue;\n");
            } else {
                printf ("Error: Calculated A residue does not match proof file residue\n\n");
            if (debug) {print_residues (A_proof, binary, SH, "  A proof  ");}
                exit (1);
            }
        }

        gwfree (&gwdata, r_gw);                 // Free the GW number: GW docs do not make it clear when this is needed
        gwdone (&gwdata);                       // Free all GW data
    }
    if (m == 0) { // If we have a Mersenne exponent we also need to perform a modular division by the square of the base
        if (debug) {print_residues (B, binary, SH, " Undivided ");}
        mpz_mul (S, GMPbase, GMPbase);
        x = mpz_invert (tmp, S, F);
        if (x == 0) {
            printf ("Error: no modular inverse for square of base\n");  // Hopefully we never need to use this code
            mpz_tdiv_r (tmp, B, S);                                     // if you ever see this error, and exp is prime,
            if (mpz_cmp_ui (tmp, 0L) == 0) {                            // please let CXC know
                mpz_div (A, B, S);
                if (use_proof_res) symb = "Suyama A residue from proof"; else symb = "Square of penultimate residue";
                printf ("%s trivially divisible by %lu\n", symb, mpz_get_ui (S));
            } else {
                i = 1;
                while (i != 0) {
                    mpz_sub (A, A, F);
                    mpz_tdiv_r (tmp, A, S);
                    x++;
                    i = mpz_get_ui (tmp);
                    if (x > mpz_get_ui (S)) {printf ("Simple-minded modular division failed. Exiting\n\n"); exit (1);}
                }
                mpz_div (A, A, S);
                mpz_set_ui (tmp, 1L);
                if (debug) printf ("Simple-minded modular division by square of base, subtractions = %lu\n", x);
            }
        }
        mpz_mul (A, A, tmp);
        mpz_tdiv_r (A, A, F);
        if (debug) {print_residues (A, binary, SH, "  Divided  ");}
    }
    if (verbose) {
        if (len < 5) { // print full residues if they are 4 or less words in size
            printf ("Suyama A residue: ");
            for (i = len; i > 0; i--) {
                printf ("%016lx\n", r_bin[i-1]);
            }
            printf ("\n");
        } else  printf ("Suyama A residue: length = %d words, %016lx %016lx ... %016lx %016lx\n", len, r_bin[len-1], r_bin[len-2], r_bin[1], r_bin[0]);
    }
    if (super_verbose || (verbose && m < 12)) {
        printf ("\nSuyama A == ");
        mpz_out_str (stdout, 10, A);
        printf (" modulo F%d\n\n", m);
    }

    if (k_fact > 0 && use_proof_res) printf ("Gerbicz check of proof residue:\n");  // Gerbicz sanity check, if there are known factors
    if ((k_fact > 0 && jacobi != -1) || (m == 0 && n_fact > 0)) printf ("Gerbicz check of Fermat-PRP residue:\n");
    for (i = 0; i < k_fact; i++) {              // note, A == b^2^2^m mod F_m = b^(F_m - 1) mod F_m
        mpz_tdiv_r (P, A, kfac[i]);             // P == A (mod p), where p is a prime factor of F_m
        mpz_set_ui (S, 1L);
        mpz_mul_2exp (B, S, exp);               // B = 2^2^m
        mpz_sub (tmp, kfac[i], S);              // tmp = p - 1
        mpz_tdiv_r (S, B, tmp);                 // S == 2^2^m (mod p - 1)
        mpz_powm (B, GMPbase, S, kfac[i]);         // B == b^S (mod p), which should == A
        if ((use_proof_res || jacobi != -1 || verbose) && mpz_cmp (P, B) == 0) {
            printf ("A == ");
            mpz_out_str (stdout, 10, GMPbase);
            printf ("^(2^%lu mod ", exp);
            mpz_out_str (stdout, 10, tmp);
            printf (") == ");
            mpz_out_str (stdout, 10, B);
            printf (" mod ");
            mpz_out_str (stdout, 10, kfac[i]);
            printf ("\n");
        } else if (mpz_cmp (P, B) != 0) {
            if (use_proof_res) symb = " with proof"; else symb = "";
            printf ("Problem%s: Suyama A residue has been calculated incorrectly!\n\n", symb);
            exit (1);
        }
    }
    if (debug) printf ("n_comp = %d\n", n_comp);
//             if (debug) printf ("ncomp[%d] = %d\n", i, ncomp[i]); // from loop below
    if (m == 0 && n_comp == 0) {                // For Mersennes we only have supplied factors (which may not be
        for (i = 0; i < n_fact; i++) {          // prime), and we need to modify the exponent (mod factor - 1)
            if (ncomp[i] == 0) {                // owing to the modular division step, by subtracting 2.
                mpz_tdiv_r (P, A, fact[i]);     // Note, Gerbicz's trick only works on prime factors.
                mpz_set_ui (S, 1L);             // P == A (mod p)
                mpz_mul_2exp (B, S, exp);       // B =  2^exp
                mpz_sub_ui (B, B, 2L);          // B = 2^exp - 2
                mpz_sub (tmp, fact[i], S);      // tmp = p - 1
                mpz_tdiv_r (S, B, tmp);         // S == 2^exp - 2 (mod p - 1)
                mpz_powm (B, GMPbase, S, fact[i]); // B == b^S (mod p), which should == A
                if (mpz_cmp (P, B) == 0) {
                    printf ("A == ");
                    mpz_out_str (stdout, 10, GMPbase);
                    printf ("^(2^%lu-2 mod ", exp);
                    mpz_out_str (stdout, 10, tmp);
                    printf (") == ");
                    mpz_out_str (stdout, 10, B);
                    printf (" mod ");
                    mpz_out_str (stdout, 10, fact[i]);
                    printf ("\n");
                } else {
                    if (use_proof_res) symb = " with proof"; else symb = "";
                    printf ("Problem%s: Suyama A residue may have been calculated incorrectly!\n\n", symb);
                    mpz_tdiv_r (tmp, F, GMPbase);
                    if (mpz_cmp_ui (tmp, 0L) == 0) printf ("Please choose a PRP base that is not a factor of the Mersenne number.\n\n");
                    exit (1);
                }
            }
        }
    }
    if (k_fact > 0 || n_fact > 0) {
        if (use_proof_res) {symb = " from proof";} else if (jacobi == -1) {symb = " also";} else {symb = "";}
        printf ("Suyama A residue%s passes check.\n\n", symb);
    }
    if (m == 0) {
        printf ("M%lu is ", exp);
        if (mpz_cmp_ui (A, 1L) == 0) printf ("(probably) prime!\n\n"); else printf ("composite.\n\n");
    } else if (jacobi != -1 && prp == 0) {
        printf ("F%d is ", m);
        if (mpz_cmp_ui (A, 1L) == 0) printf ("(probably) prime!\n\n"); else printf ("composite.\n\n");
    }

    // If known factors were provided perform the Suyama test to determine whether the remaining cofactor C is prime or composite
    if (n_fact > 0) {
        if (m == 0) printf ("Testing the M%lu ", exp); else printf ("Testing the F%d ", m);
        if (known_factors) {symb = "known";} else {symb = "supplied";}
        printf ("cofactor for primality using the following %d %s factor", n_fact, symb);
        if (n_fact > 1) printf ("s: "); else printf (": ");
        for (i = 0; i < n_fact; i++) {
            mpz_out_str (stdout, 10, fact[i]);
            printf (" ");
        }
        printf ("\n");

        digits = num_digits (C);
        if (n_fact > 1 && digits > 1) {
            printf ("Product of %s ", symb);
            print_mpz (Q, 10, "factors");
        }

        if ((super_verbose || (m > 0 && m < 12) || (m == 0 && exp < 4096)) && digits > 1) {
            printf ("Cofactor (%d digits): ", digits);
            mpz_out_str (stdout, 10, C);
            if ((binary & 2) == 2) print_mpz (C, 2, "\nBinary representation");
            printf ("\n");
        } else {
            if (digits > 1) {
                printf ("Cofactor is %d digits long\n", digits);
            } else {
                if (mpz_cmp_ui (C, 1L) == 0) {
                    printf ("Suyama test is not required, as product of submitted factors = ");
                    if (m == 0) printf ("M%lu", exp); else printf ("F%d", m);
                }
                else {
                    printf ("Cofactor (1 digit): ");
                    mpz_out_str (stdout, 10, C);
                }
                printf ("\n");
            }
        }
    }

    // Break out of cofactor processing for a moment, so that F20 and F24 get their A residues printed
    if (exp > 36) printf ("                                        |      Selfridge - Hurwitz residues\n                       mod 2^64 (hex)   |   mod 2^36    mod 2^36-1   mod 2^35-1\n");
    print_residues (A, binary, SH, "Suyama    A");
    fflush (stdout);

    // Back into cofactor processing if cofactor is non-trivial
    if (n_fact > 0 && mpz_cmp_ui (C, 1L) != 0) {
        if (modc) {
            mpz_mod (tmp, A, C);              // A mod C
            print_residues (tmp, binary, SH, "    A mod C");
            fflush (stdout);
        }

        // Calculate B = b^(Q-1) mod F
//         mpz_sub_ui (tmp, Q, 1L);
//         mpz_powm (B, GMPbase, tmp, F);

        // Alternate (and slightly faster) algorithm to calculate B = b^(Q-1) mod F
        j = mpz_sizeinbase (Q, 2L);
        mpz_set (B, GMPbase);
        mpz_set_ui (tmp, 1L); if (debug) printf ("Generating b^(Q-1), Q-1 = "); // use debug if you are concerned it doesn’t work properly!
        for (i = j - 1; i > 0; i--) {
            x = mpz_tstbit (Q, i);
            if (x == 1 && i > 0 && i < j - 1) {mpz_mul (B, B, GMPbase); mpz_add_ui (tmp, tmp, 1L); }
            if (debug) {mpz_out_str (stdout, 10, tmp); printf (" ... "); fflush (stdout);}
            mpz_mul (B, B, B); mpz_mul_ui (tmp, tmp, 2L);
            mpz_tdiv_r (B, B, F);
        }
        if (debug) {mpz_out_str (stdout, 10, tmp); if (mpz_cmp (Q, tmp) == 1) printf (" = Q-1\n");}
        print_residues (B, binary, SH, "Suyama    B");
        fflush (stdout);
        if (modc) {
            mpz_mod (tmp, B, C);              // B mod C
            print_residues (tmp, binary, SH, "    B mod C");
            fflush (stdout);
        }

        // Calculate S = (A - B) mod C, using the P and Q variables as a stand-in for Suyama
        mpz_sub (P, A, B);                  // S = A - B
        mpz_mod (Q, P, C);                  // S = (A - B) mod C

        if (verbose || debug) print_residues (P, binary, SH, "Suyama  A-B");
        if (verbose || debug) print_residues (C, binary, SH, "Cofactor  C");
        print_residues (Q, binary, SH, "(A-B) mod C");
        fflush (stdout);

        if (mpz_cmp_ui (Q, 0L) == 0) {
            if (m == 0) printf ("M%lu ", exp); else printf ("F%d ", m);
            printf ("cofactor is (probably) prime!\n");
        } else {
            mpz_gcd (P, P, C);              // P = GCD ((A - B), C)
            print_mpz (P, 10, "GCD (A-B, C)");
            if (mpz_cmp_ui (P, 1L) == 0) {symb = "not";} else {symb = "also";}
            if (m == 0) printf ("M%lu ", exp); else printf ("F%d ", m);
            printf ("cofactor is composite, and is %s a prime power\n", symb);
            fflush (stdout);
        }
        if (m == 0) printf ("\nFactorisation: M%lu = ", exp); else printf ("\nFactorisation: F%d = ", m);
        for (i = 0; i < n_fact; i++) {
            if (ncomp[i] == 0) {symb = "p";} else {symb = "c";}
            printf ("%s%d ", symb, num_digits (fact[i]));
            if (i < n_fact) printf ("* ");
        }
        if (mpz_cmp_ui (Q, 0L) == 0 || mpz_cmp_ui (C, 3L) == 0) {symb = "prp";} else {symb = "c";}
        printf ("%s%d\n\n", symb, num_digits (C));
    } else if (n_fact > 1) {
        if (m == 0) printf ("\nFactorisation: M%lu = ", exp); else printf ("\nFactorisation: F%d = ", m);
        for (i = 0; i < n_fact; i++) {
            if (ncomp[i] == 0) {symb = "p";} else {symb = "c";}
            printf ("%s%d ", symb, num_digits (fact[i]));
            if (i < n_fact - 1) printf ("* ");
        }
        printf ("\n\n");
    } else {
        if (m == 0) printf ("\nFactorisation: M%lu = ", exp); else printf ("\nFactorisation: F%d = ", m);
        if (z == 1) {symb = "p";} else {symb = "c";}
        if (m == 0 && mpz_cmp_ui (A, 1L) == 0) symb = "p";
        printf ("%s%d\n\n", symb, num_digits (F));
    }

fast_exit:
    current_time = time(NULL);

    if (json && n_fact > 0) {
        if (mpz_cmp_ui (Q, 0L) == 0) symb = "P"; else symb = "C";
        i = mpz_get_ui (GMPbase);
        mpz_and (r64, A, mask64);
        j = mpz_get_ui (r64);
        mpz_tdiv_r_2exp (tmp, A, 2048L);
        printf ("Manual results JSON string: {\"status\":\"%s\", \"exponent\":%lu, \"worktype\":\"PRP-%d\", \"res64\":\"%016lX\", \"residue-type\":5, \"res2048\":\"", symb, exp, i, j);
        mpz_out_str (stdout, 16, tmp);
        if (fft_length) printf ("\", \"fft-length\":%d", fft_length);
        time_block = gmtime(&current_time);
        strftime(time_string, TIME_STRING_LEN, "%Y-%m-%d %X", time_block);
        printf (", \"shift-count\":0, \"error-code\":\"00000000\", \"program\":{\"name\":\"%s\", \"version\":\"%s\", \"port\":10}, \"timestamp\":\"%s\", \"known-factors\":[", prog_name, prog_vers, time_string);
        for (i = 0; i < n_fact; i++) {
            symb = "\"";
            printf ("%s", symb);
            mpz_out_str (stdout, 10, fact[i]);
            if (i+1 < n_fact) symb = "\", ";
            printf ("%s", symb);
        }
        printf ("]");
        if (who > 0) printf (", \"user\":\"%s\"", argv[who]);
        if (computer > 0) printf (", \"computer\":\"%s\"", argv[computer]);
        printf ("}\n\n");
    }

    // Print the date and time the program ended and the total wall time
    time_block = localtime(&current_time);
    strftime(time_string, TIME_STRING_LEN, "%A %d %B %Y %X", time_block);

    (void) gettimeofday(&tv_stop, (struct timezone *) 0);
    wall_time = tv_secs(tv_stop) - tv_secs(tv_start);
    wall_hours = wall_time / 3600;
    wall_mins = (wall_time - (wall_hours * 3600)) / 60;
    wall_secs = (wall_time - (wall_hours * 3600) - (wall_mins * 60));
    i = (wall_time - (wall_hours * 3600) - (wall_mins * 60) - wall_secs) * 1000000;
    // if a job completes in fewer than ten seconds, print milli- or microseconds as well
    printf ("Run ended: %s, Wall time = %d:%02d:%02d", time_string, wall_hours, wall_mins, wall_secs);
    if (wall_time < 0.002) printf (".%06d (HH:MM:SS.us)\n\n", i);
    else if (wall_time < 10) printf (".%03d (HH:MM:SS.ms)\n\n", i / 1000);
    else printf (" (HH:MM:SS)\n\n");

//     printf ("Run ended: %s, Wall time = %d:%02d:%02d (HH:MM:SS)\n\n", time_string, wall_hours, wall_mins, wall_secs);

    if (sep) printf ("----------------------------------------------------------------------------------------------------\n");
}
